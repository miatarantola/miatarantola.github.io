[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "My Awesome CSCI 0451 Blog",
    "section": "",
    "text": "A blog post for our final project prep\n\n\n\n\n\n\nMay 11, 2023\n\n\nMia Tarantola, Bridget Ulian, Kate Kenny\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\nFinal project on determining urban air pollution by income and racial demographics.\n\n\n\n\n\n\nMay 10, 2023\n\n\nBridget Ulian, Kate Kenny, Mia Tarantola\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nA blog post relating to our talk with Timnit Gebru\n\n\n\n\n\n\nApr 16, 2023\n\n\nMia Tarantola\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\nA blog post relating to unsupervised learning and image compression\n\n\n\n\n\n\nApr 16, 2023\n\n\nMia Tarantola\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nA blog post investigating the bias of prediction models\n\n\n\n\n\n\nApr 2, 2023\n\n\nMia Tarantola\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAn blog post illustrating the key techniques of linear regression\n\n\n\n\n\n\nApr 2, 2023\n\n\nMia Tarantola\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\nAn blog post practing machine learning techniques on real life data\n\n\n\n\n\n\nMar 10, 2023\n\n\nMia Tarantola\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAn blog post illustrating the key techniques of gradient descent\n\n\n\n\n\n\nMar 9, 2023\n\n\nMia Tarantola\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\nAn blog post illustrating course material on perceptrons\n\n\n\n\n\n\nFeb 19, 2023\n\n\nMia Tarantola\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\nAn example blog post illustrating the key techniques you’ll need to demonstrate your learning in CSCI 0451.\n\n\n\n\n\n\nJan 10, 2023\n\n\nPhil Chodrow\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "posts/Auditing Allocative Bias/Auditing Allocative Bias nb.html",
    "href": "posts/Auditing Allocative Bias/Auditing Allocative Bias nb.html",
    "title": "Auditing Allocative Bias",
    "section": "",
    "text": "In this blog post I will implement a machine learning model that predicts whether an individual’s income is over 50k on the basis of demographics excluding sex. I will also audit for gender bias"
  },
  {
    "objectID": "posts/Auditing Allocative Bias/Auditing Allocative Bias nb.html#imports",
    "href": "posts/Auditing Allocative Bias/Auditing Allocative Bias nb.html#imports",
    "title": "Auditing Allocative Bias",
    "section": "Imports",
    "text": "Imports\n\nfrom folktables import ACSDataSource, ACSEmployment, BasicProblem, adult_filter\nimport numpy as np\nimport seaborn as sns"
  },
  {
    "objectID": "posts/Auditing Allocative Bias/Auditing Allocative Bias nb.html#building-data",
    "href": "posts/Auditing Allocative Bias/Auditing Allocative Bias nb.html#building-data",
    "title": "Auditing Allocative Bias",
    "section": "Building Data",
    "text": "Building Data\nFor this model we will be looking at PUMS data for the state of New Jersey. We also need to change the PINCP column values. Currently, the values represent the total income of the individual. Now we need it to represent 0 if the individual’s income was atleast $50,000 and 0 if it was less.\n\nSTATE = \"NJ\"\n\ndata_source = ACSDataSource(survey_year='2018', \n                            horizon='1-Year', \n                            survey='person')\n\nacs_data = data_source.get_data(states=[STATE], download=True)\nacs_data.loc[acs_data.PINCP <=50000,\"PINCP\"]=0\nacs_data.loc[acs_data.PINCP >50000,\"PINCP\"]=1\n\n# acs_data.head()\n\nThis data set includes many features/ columns so we will be narrowing them down to a smaller subset of feeatures to consider\n\npossible_features=['AGEP', 'SCHL', 'MAR', 'RELP', 'DIS', 'ESP', 'CIT', 'MIG', 'MIL', 'ANC', 'NATIVITY', 'DEAR', 'DEYE', 'DREM', 'SEX',\"PINCP\", 'RAC1P', 'ESR']\nacs_data[possible_features].head()\n\n\n\n\n\n  \n    \n      \n      AGEP\n      SCHL\n      MAR\n      RELP\n      DIS\n      ESP\n      CIT\n      MIG\n      MIL\n      ANC\n      NATIVITY\n      DEAR\n      DEYE\n      DREM\n      SEX\n      PINCP\n      RAC1P\n      ESR\n    \n  \n  \n    \n      0\n      23\n      21.0\n      5\n      17\n      2\n      NaN\n      5\n      2.0\n      4.0\n      1\n      2\n      2\n      2\n      2.0\n      1\n      0.0\n      6\n      6.0\n    \n    \n      1\n      51\n      20.0\n      4\n      17\n      2\n      NaN\n      4\n      1.0\n      4.0\n      1\n      2\n      2\n      2\n      2.0\n      1\n      0.0\n      1\n      1.0\n    \n    \n      2\n      69\n      19.0\n      3\n      16\n      1\n      NaN\n      1\n      1.0\n      4.0\n      4\n      1\n      2\n      2\n      2.0\n      1\n      0.0\n      1\n      6.0\n    \n    \n      3\n      18\n      16.0\n      5\n      16\n      1\n      NaN\n      1\n      1.0\n      4.0\n      2\n      1\n      2\n      2\n      1.0\n      2\n      0.0\n      9\n      6.0\n    \n    \n      4\n      89\n      19.0\n      2\n      16\n      1\n      NaN\n      1\n      1.0\n      4.0\n      4\n      1\n      2\n      2\n      1.0\n      2\n      0.0\n      1\n      6.0\n    \n  \n\n\n\n\nsubsetting the features:\n\nfeatures_to_use = [f for f in possible_features if f not in [\"PINCP\", \"SEX\"]]\n\nNow we construct a basic problem to express our wish to use these features to predict if income (PINCP) >=$50,000 , using the race RAC1P as the group label\n\nIncomeProblem = BasicProblem(\n    features=features_to_use,\n    target='PINCP',\n    target_transform=lambda x: x == 1,\n    group='SEX',\n    preprocess=lambda x: x,\n    postprocess=lambda x: np.nan_to_num(x, -1),\n)\n\nfeatures, label, group = IncomeProblem.df_to_numpy(acs_data)\n\nThe result is a features matrix, a label vector and a group label vector\n\nfor obj in [features, label, group]:\n  print(obj.shape)\n\n(88586, 16)\n(88586,)\n(88586,)\n\n\nWe should perform a train-test split to split our data into training and testing subsets\n\nfrom sklearn.model_selection import train_test_split\nX_train, X_test, y_train, y_test, group_train, group_test = train_test_split(\n    features, label, group, test_size=0.2, random_state=0)"
  },
  {
    "objectID": "posts/Auditing Allocative Bias/Auditing Allocative Bias nb.html#basic-descriptives",
    "href": "posts/Auditing Allocative Bias/Auditing Allocative Bias nb.html#basic-descriptives",
    "title": "Auditing Allocative Bias",
    "section": "Basic Descriptives",
    "text": "Basic Descriptives\n\nimport pandas as pd\ndf = pd.DataFrame(X_train, columns = features_to_use)\ndf[\"group\"] = group_train\ndf[\"label\"] = y_train\ndf\n\n\n\n\n\n  \n    \n      \n      AGEP\n      SCHL\n      MAR\n      RELP\n      DIS\n      ESP\n      CIT\n      MIG\n      MIL\n      ANC\n      NATIVITY\n      DEAR\n      DEYE\n      DREM\n      RAC1P\n      ESR\n      group\n      label\n    \n  \n  \n    \n      0\n      31.0\n      14.0\n      5.0\n      0.0\n      2.0\n      0.0\n      2.0\n      3.0\n      4.0\n      1.0\n      1.0\n      2.0\n      2.0\n      2.0\n      1.0\n      1.0\n      2\n      False\n    \n    \n      1\n      40.0\n      21.0\n      1.0\n      1.0\n      2.0\n      0.0\n      5.0\n      1.0\n      4.0\n      1.0\n      2.0\n      2.0\n      2.0\n      2.0\n      6.0\n      6.0\n      2\n      False\n    \n    \n      2\n      40.0\n      22.0\n      1.0\n      0.0\n      2.0\n      0.0\n      5.0\n      1.0\n      4.0\n      1.0\n      2.0\n      2.0\n      2.0\n      2.0\n      6.0\n      1.0\n      1\n      True\n    \n    \n      3\n      34.0\n      21.0\n      1.0\n      1.0\n      2.0\n      0.0\n      1.0\n      3.0\n      4.0\n      2.0\n      1.0\n      2.0\n      2.0\n      2.0\n      1.0\n      1.0\n      2\n      True\n    \n    \n      4\n      75.0\n      20.0\n      5.0\n      0.0\n      1.0\n      0.0\n      1.0\n      1.0\n      4.0\n      1.0\n      1.0\n      2.0\n      2.0\n      2.0\n      1.0\n      6.0\n      2\n      False\n    \n    \n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n    \n    \n      70863\n      66.0\n      21.0\n      4.0\n      0.0\n      2.0\n      0.0\n      1.0\n      1.0\n      4.0\n      2.0\n      1.0\n      2.0\n      2.0\n      2.0\n      1.0\n      1.0\n      2\n      False\n    \n    \n      70864\n      32.0\n      16.0\n      5.0\n      2.0\n      2.0\n      0.0\n      1.0\n      1.0\n      4.0\n      2.0\n      1.0\n      2.0\n      2.0\n      2.0\n      1.0\n      1.0\n      1\n      False\n    \n    \n      70865\n      54.0\n      22.0\n      1.0\n      0.0\n      2.0\n      0.0\n      1.0\n      1.0\n      4.0\n      1.0\n      1.0\n      2.0\n      2.0\n      2.0\n      1.0\n      1.0\n      1\n      True\n    \n    \n      70866\n      42.0\n      19.0\n      1.0\n      0.0\n      2.0\n      0.0\n      1.0\n      1.0\n      4.0\n      1.0\n      1.0\n      2.0\n      2.0\n      2.0\n      1.0\n      1.0\n      1\n      False\n    \n    \n      70867\n      38.0\n      14.0\n      5.0\n      0.0\n      2.0\n      0.0\n      1.0\n      1.0\n      4.0\n      1.0\n      1.0\n      2.0\n      2.0\n      2.0\n      2.0\n      1.0\n      2\n      False\n    \n  \n\n70868 rows × 18 columns\n\n\n\nThere are 70868 individuals in the data. Now lets look at what proportion have the target label equal to 1\n\n(df[\"label\"]==1).mean()\n\n0.29835750973641134\n\n\n31.2% of the data has a target label of 1 meaning 31.2% of the individuals had a total income of at least $50,000. Now, let’s check how many people are in each of the groups. The distribution is as follows:\n\ndf[\"group\"].value_counts()\n\n2    36491\n1    34377\nName: group, dtype: int64\n\n\nNow we will look at what proportion of individuals have the target label equal to 1. The distribution values are below\n\ndf.groupby([\"group\"])[\"label\"].mean()\n\ngroup\n1    0.363237\n2    0.237237\nName: label, dtype: float64\n\n\nNow we will look at intersectional trends\n\nmeans = df.groupby([\"group\",\"RAC1P\"])[\"label\"].mean().reset_index(name = \"proportion of individuals that have target label of 1\")\np = sns.barplot(data = means, x = \"group\", y = \"proportion of individuals that have target label of 1\", hue = \"RAC1P\")\n\n\n\n\n\n\n\nGroup\nRAC1P\n\n\n\n\n1: male\n1: White alone\n\n\n2: female\n2: Black or African American alone\n\n\n\n3: American Indian alone\n\n\n\n4: Alaska Native alone\n\n\n\n5: American Indian, Alaska Native alone\n\n\n\n6: Asian alone\n\n\n\n7: Native Hawaiian and Other Pacific Islander alone\n\n\n\n8: Some other race alone\n\n\n\n9: Two or More Races\n\n\n\nWe are looking to see the breakdown of individuals who have a target label of 1 (meaning they have an income >=$50,000) given their race and gender. We can use the mean as our metric because our target label is binary. So, the mean is the proportion of labels with the value 1. It seems like white and asians are the groups with the highest proportion of individuals that have a target label of 1 within both genders\n\nmeans = df.groupby([\"group\",\"DIS\"])[\"label\"].mean().reset_index(name = \"proportion of individuals that have target label of 1\")\np = sns.barplot(data = means, x = \"group\", y = \"proportion of individuals that have target label of 1\", hue = \"DIS\")\n\n\n\n\nFor the both groups, there is a correlation between an income over $50,000 and disability status"
  },
  {
    "objectID": "posts/Auditing Allocative Bias/Auditing Allocative Bias nb.html#training-a-model",
    "href": "posts/Auditing Allocative Bias/Auditing Allocative Bias nb.html#training-a-model",
    "title": "Auditing Allocative Bias",
    "section": "Training a model",
    "text": "Training a model\nWe will build our model using a decision tree approach. Let’s use cross validation to determine the best depth.\n\nfrom sklearn.svm import SVC\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.pipeline import make_pipeline\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.metrics import confusion_matrix\nfrom sklearn.model_selection import cross_val_score\nfrom sklearn.tree import DecisionTreeClassifier\n\nbest_score = -np.inf\nbest_depth = 0\n\nfor depth in range(2,10):\n    pipeline = make_pipeline(StandardScaler(),DecisionTreeClassifier(max_depth = depth))\n    scores = cross_val_score(pipeline,X_train,y_train,cv = 6)\n    if scores.mean()>best_score:\n            best_score = scores.mean()\n            best_depth = depth\nprint(best_depth,best_score)\n    \n\n8 0.8248292705055139\n\n\nNow, let’s build our final model\n\nmodel = make_pipeline(StandardScaler(),DecisionTreeClassifier(max_depth=8))\nmodel.fit(X_train,y_train)\n\nPipeline(steps=[('standardscaler', StandardScaler()),\n                ('decisiontreeclassifier',\n                 DecisionTreeClassifier(max_depth=8))])In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.PipelinePipeline(steps=[('standardscaler', StandardScaler()),\n                ('decisiontreeclassifier',\n                 DecisionTreeClassifier(max_depth=8))])StandardScalerStandardScaler()DecisionTreeClassifierDecisionTreeClassifier(max_depth=8)\n\n\nNow we can generate predictions:\n\ny_hat = model.predict(X_test)\n\n\n\nOverall Metrics\nThe overall accuracy of the model represents the percentage of times that it will correctly predict the target label. So, we are comparing the correct labels to the target labels and taking the mean. Because our label is binary we can take the mean of our equivalence array as the number of times 1 appear (signifying the labels match) is the mean\n\nprint(\"The overall accuracy of this model is: \" + str((y_hat==y_test).mean().round(4)))\n\nThe overall accuracy of this model is: 0.8219\n\n\nTo find the PPV of our model we first need to calculate the number of true positives and false positives. To do so, we compare the predicted labels to the test labels. If the predicted label is 1 and the acutal label is 1, then that is a true positive. If the predicted label is 1 and the true label is 0 that is a false positive.\n\nTP = len((np.where((y_hat==1) & (y_test==1))[0]))\nFP = len((np.where((y_hat==1) & (y_test==0))[0]))\nPPV = round((TP)/(TP+FP),4)\nprint(\"The positive predictive value of this model is: \" + str(PPV))\n\nThe positive predictive value of this model is: 0.709\n\n\nThe FPR represents the rate at which a test label of 0 is incorrectly predicted to be 1. THE FNR represents the rate at which a test label of 1 is incorrectly predicted to be 0.\n\nconf_matrix = confusion_matrix(y_test,y_hat, normalize = 'true')\nprint(\"FPR = \" + str(conf_matrix[0][1]))\nprint(\"FNR = \" + str(conf_matrix[1][0])) \n\nFPR = 0.11853101896496303\nFNR = 0.3187334091770952"
  },
  {
    "objectID": "posts/Auditing Allocative Bias/Auditing Allocative Bias nb.html#by-group-measures",
    "href": "posts/Auditing Allocative Bias/Auditing Allocative Bias nb.html#by-group-measures",
    "title": "Auditing Allocative Bias",
    "section": "By Group Measures",
    "text": "By Group Measures\nNow we will compare the accuracy of our model for individual groups. So we filter by gender\n\nprint(\"The accuracy for male individuals is \" + str((y_hat==y_test)[group_test==1].mean().round(4)))\nprint(\"The accuracy for female individuals is \" + str((y_hat==y_test)[group_test==2].mean().round(4)))\n\nThe accuracy for male individuals is 0.8181\nThe accuracy for female individuals is 0.8255\n\n\nNow we will copmare some of the accuracy metrics such as the false positive rate and the false negative rate. They are about equal for both genders which is generally a good sign\n\nconf_matrix_male_norm = confusion_matrix(y_test[group_test==1],y_hat[group_test==1], normalize = 'true')\nprint(\"FPR for male individuals = \" + str(conf_matrix_male_norm[0][1]))\nprint(\"FNR for male individuals = \" + str(conf_matrix_male_norm[1][0])) \n\nconf_matrix_female_norm = confusion_matrix(y_test[group_test==2],y_hat[group_test==2], normalize = 'true')\nprint(\"FPR for female individuals = \" + str(conf_matrix_female_norm[0][1]))\nprint(\"FNR for female individuals = \" + str(conf_matrix_female_norm[1][0])) \n\nFPR for male individuals = 0.1007483117357182\nFNR for male individuals = 0.32504038772213245\nFPR for female individuals = 0.1323761665470208\nFNR for female individuals = 0.3088572739788894"
  },
  {
    "objectID": "posts/Auditing Allocative Bias/Auditing Allocative Bias nb.html#bias-measures",
    "href": "posts/Auditing Allocative Bias/Auditing Allocative Bias nb.html#bias-measures",
    "title": "Auditing Allocative Bias",
    "section": "Bias Measures",
    "text": "Bias Measures\nCalibration means that the fraction of predicted people to have an income >= $$$50,000 who actually had an income >=$50,000 is the same across all groups. So we will calculate this metric for both genders. This metric can be calculated by dividing the number of true positives by the total number of predicted positives.\n\nconf_matrix_male = confusion_matrix(y_test[group_test==1],y_hat[group_test==1])\nmale_calibration = confusion_matrix(y_test[group_test==1],y_hat[group_test==1])[0][0]/(confusion_matrix(y_test[group_test==1],y_hat[group_test==1])[0].sum())\nconf_matrix_female = confusion_matrix(y_test[group_test==2],y_hat[group_test==2])\nfemale_calibration = confusion_matrix(y_test[group_test==2],y_hat[group_test==2])[0][0]/(confusion_matrix(y_test[group_test==2],y_hat[group_test==2])[0].sum())\n\nprint(\"The fraction of males predicted to have an income >=$50000 who actually had an income of >=$50000 is \" + str(male_calibration.round(4)))\nprint(\"The fraction offe males predicted to have an income >=$50000 who actually had an income of >=$50000 is \" + str(female_calibration.round(4)))\n\n\nThe fraction of males predicted to have an income >=$50000 who actually had an income of >=$50000 is 0.8993\nThe fraction offe males predicted to have an income >=$50000 who actually had an income of >=$50000 is 0.8676\n\n\nI would say that the model is calibrated as the proportions for each group are roughly the same.\nA model satisfies error rate balance if the false positive and false negative rates are equal across groups. Looking at the previously calculated FPR anf FNR, I would say that this model satidfies error rate balance. The FPR for both groups is rounghly 12% and the FNR for both groups is roughly 31%.\nA model satisifes statistical parity if the proportion of individuals classified as having an income >=$50000 is the same for each group. So we compare the total number of predicted positives.\n\nprint(\"The proportion of males classified as having an income greater than $50,000 is \" + str((confusion_matrix(y_test[group_test==1],y_hat[group_test==1])[0].sum())/34377))\nprint(\"The proportion of females classified as having an income greater than $50,000 is \" + str((confusion_matrix(y_test[group_test==2],y_hat[group_test==2])[0].sum())/36491))\n\nThe proportion of males classified as having an income greater than $50,000 is 0.1593798179015039\nThe proportion of females classified as having an income greater than $50,000 is 0.19086898139267217\n\n\nAgain, these values are roughly the same, so I would say that this model satisfies statistical parity.\n\nCompanies like banks or credit card companies could benefit from this model. Banks often give out loans and need to asses how much money is a safe amount to give to their clients. Knowing their clients’ incomes would be very helpful in assesing the risks of pursuing a loan. Credit card companies follow a similar process when determining to accept a clients’ credit card request.\nI think it is interesting that this model gives companies/organizations that don’t usually have access to your income more insight into your financials. Job employers usually don’t have access to your current salary/wage, but now this algorithm will give them more insight and could potentially help them in deciding a new salary offer. Places like country clubs, whos reputation is encompassed by wealth, could use this kind of algorithm.\nBased on my bias audit, I don’t think that my model displays problematic bias. The model satisifies the calibration, error rate and statistical parity tests. So, there is no obvious bias, but as always more investigating is also helpful.\nIn my opion the accuracy of this model is not high enoughly to be deployed. The accuracy of the model is about 80% meaning it predicts the wrong out come 20% of the time. To put this into perspective, this model is incorrect for every 5th person. To help remedy this, I would suggest either collecting more data or reevaluating the parameters/factors involved"
  },
  {
    "objectID": "posts/Classifying Palmer Penguins/Penguin Blog Post.html",
    "href": "posts/Classifying Palmer Penguins/Penguin Blog Post.html",
    "title": "Penguin Blog Post",
    "section": "",
    "text": "import pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\ntrain_url = \"https://raw.githubusercontent.com/middlebury-csci-0451/CSCI-0451/main/data/palmer-penguins/train.csv\"\ntrain = pd.read_csv(train_url)\n\n\n\nfrom sklearn.preprocessing import LabelEncoder\nle = LabelEncoder()\nle.fit(train[\"Species\"])\n\ndef prepare_data(df):\n  df = df.drop([\"studyName\", \"Sample Number\", \"Individual ID\", \"Date Egg\", \"Comments\",\"Region\"], axis = 1)\n  df = df[df[\"Sex\"] != \".\"]\n  df = df.dropna()\n  y = le.transform(df[\"Species\"])\n  df = df.drop([\"Species\"], axis = 1)\n  df = pd.get_dummies(df)\n  return df, y\n\nX_train, y_train = prepare_data(train)\n\n\nX_train.head() #looking at data\n\n\n\n\n\n  \n    \n      \n      Culmen Length (mm)\n      Culmen Depth (mm)\n      Flipper Length (mm)\n      Body Mass (g)\n      Delta 15 N (o/oo)\n      Delta 13 C (o/oo)\n      Island_Biscoe\n      Island_Dream\n      Island_Torgersen\n      Stage_Adult, 1 Egg Stage\n      Clutch Completion_No\n      Clutch Completion_Yes\n      Sex_FEMALE\n      Sex_MALE\n    \n  \n  \n    \n      1\n      45.1\n      14.5\n      215.0\n      5000.0\n      7.63220\n      -25.46569\n      1\n      0\n      0\n      1\n      0\n      1\n      1\n      0\n    \n    \n      2\n      41.4\n      18.5\n      202.0\n      3875.0\n      9.59462\n      -25.42621\n      0\n      0\n      1\n      1\n      0\n      1\n      0\n      1\n    \n    \n      3\n      39.0\n      18.7\n      185.0\n      3650.0\n      9.22033\n      -26.03442\n      0\n      1\n      0\n      1\n      0\n      1\n      0\n      1\n    \n    \n      4\n      50.6\n      19.4\n      193.0\n      3800.0\n      9.28153\n      -24.97134\n      0\n      1\n      0\n      1\n      1\n      0\n      0\n      1\n    \n    \n      5\n      33.1\n      16.1\n      178.0\n      2900.0\n      9.04218\n      -26.15775\n      0\n      1\n      0\n      1\n      0\n      1\n      1\n      0\n    \n  \n\n\n\n\n\ny_train.mean()\n\n0.95703125\n\n\n\n\n\nThe purpose of this blog post is to practice implemeting machine learning classifiers on real life data! We are looking at the plamer penguins data set collected by Dr. Kristen Gorman. Here we analyze different attributes to use in our species prediction for penguins\n\n\n\npalmer_penguins.png\n\n\n\n\n\n\nsns.relplot(data = train, x = \"Flipper Length (mm)\", y = \"Culmen Length (mm)\", hue = \"Species\", size = \"Body Mass (g)\")\n\n<seaborn.axisgrid.FacetGrid at 0x7f780c3ac9d0>\n\n\n\n\n\nThe graph explores the realtionship between species, Flipper Length and Culmen Length. We can see a clear divide between the species. The Gentoo penguins seem to have the longeth flipper and culmen length and are the heaviest. Chinstrap penguins appear to have a longer culmen length but a shorter flipper length. Adelie Penguins have the shortest Flipper and Culmen length. Despite having a longer culmen length, the chinstrap penguins are about the same weight as the Adelies.\n\ntrain.groupby(\"Species\").agg(\"mean\")\n\n/var/folders/k6/ddn01bfs47n_n5b4t6fb88q80000gp/T/ipykernel_58878/1693257315.py:1: FutureWarning: The default value of numeric_only in DataFrameGroupBy.mean is deprecated. In a future version, numeric_only will default to False. Either specify numeric_only or select only columns which should be valid for the function.\n  train.groupby(\"Species\").agg(\"mean\")\n\n\n\n\n\n\n  \n    \n      \n      Sample Number\n      Culmen Length (mm)\n      Culmen Depth (mm)\n      Flipper Length (mm)\n      Body Mass (g)\n      Delta 15 N (o/oo)\n      Delta 13 C (o/oo)\n    \n    \n      Species\n      \n      \n      \n      \n      \n      \n      \n    \n  \n  \n    \n      Adelie Penguin (Pygoscelis adeliae)\n      73.440678\n      38.710256\n      18.365812\n      189.965812\n      3667.094017\n      8.855229\n      -25.825165\n    \n    \n      Chinstrap penguin (Pygoscelis antarctica)\n      32.696429\n      48.719643\n      18.442857\n      195.464286\n      3717.857143\n      9.338671\n      -24.542886\n    \n    \n      Gentoo penguin (Pygoscelis papua)\n      61.930693\n      47.757000\n      15.035000\n      217.650000\n      5119.500000\n      8.240438\n      -26.168937\n    \n  \n\n\n\n\nThis tables looks at the quantitative variables averaged by species. It is interesting to see that the Adelie penguins have a deeper culmen, yet are significantly lighter than the Gentoo penguins. In general a larger flipper length correlates to a heavier body mass. However, the penguins with a smaller culmen depth have a lighter body mass.\n\n\n\nFirst we must check the base rate of our data set - If we were to guess one species for all samples, what would the highest accuracy be? To do this we must calculate the number of each species and compare this to the total number of penguins\n\nnum_penguins = y_train.shape[0]\nspecies1 = np.count_nonzero(y_train == 0)\nspecies2 = np.count_nonzero(y_train == 1)\nspecies3 = np.count_nonzero(y_train == 2)\n\nmax([species1,species2,species3])/num_penguins\n\n0.4140625\n\n\nHere we took the spcies with the largest number of samples and divided by the total number of penguins. This gives us our base rate. If we guessed one species for all of the penguins we would be correct at most 41% of the time\n\n\n\nfrom itertools import combinations\nimport numpy as np\nfrom sklearn.model_selection import train_test_split,GridSearchCV\nfrom sklearn import datasets\nfrom sklearn.svm import SVC\nfrom sklearn.model_selection import cross_val_score\n\nimport numpy as np \n# these are not actually all the columns: you'll \n# need to add any of the other ones you want to search for\nall_qual_cols = [\"Sex\",\"Clutch Completion\",\"Island\",\"Region\"]\nall_quant_cols = ['Culmen Length (mm)', 'Culmen Depth (mm)', 'Flipper Length (mm)', \"Body Mass (g)\"]\n\nbest_col= []\nbest_score = -np.inf\n\nbest_gamma=np.inf\n\nfor qual in all_qual_cols: \n  qual_cols = [col for col in X_train.columns if qual in col ]\n  for pair in combinations(all_quant_cols, 2):\n    cols = qual_cols + list(pair) \n    for gammas in 10**(np.arange(-4, 4,dtype=float)):\n        clf = SVC(gamma = gammas) #kernel=\"linear\",probability=True)\n        scores = cross_val_score(clf, X_train[cols], y_train, cv=5)\n        if scores.mean()>best_score:\n            best_score = scores.mean()\n            best_col= cols\n            best_gamma = gammas\nprint(best_col, best_score, best_gamma)\n        \n\n['Island_Biscoe', 'Island_Dream', 'Island_Torgersen', 'Culmen Length (mm)', 'Culmen Depth (mm)'] 0.984389140271493 0.1\n\n\nThe method above chooses the best penguin attributes to use for our model as well as the best gamma, which determines the complexity of the model. To do so we iterate through the different combinations of attributes incluiding 1 qualitative and 2 quantitative variables. We then iterate through a series of gammas and analyze the accuracy of an SVC model using cross validation. The best attributes, score and gamma are recorded for testing\n\n\nbest_model = SVC(gamma = best_gamma)\n\nHere we initialize and train a final model using our initial dataset, and optimized parameters that we just discovered\n\nbest_model.fit(X_train[sorted(best_col, reverse = True)],y_train)\n\nSVC(gamma=0.1)In a Jupyter environment, please rerun this cell to show the HTML representation or trust the notebook. On GitHub, the HTML representation is unable to render, please try loading this page with nbviewer.org.SVCSVC(gamma=0.1)\n\n\n\ntest_url = \"https://raw.githubusercontent.com/middlebury-csci-0451/CSCI-0451/main/data/palmer-penguins/test.csv\"\ntest = pd.read_csv(test_url)\n\nX_test, y_test = prepare_data(test)\nbest_model.score(X_test[sorted(best_col,reverse=True)], y_test)\n\n0.9558823529411765\n\n\nWe can see that the final model predicts a penguins species, given their island, culmen length and culmen depth with 95% accuracy. This is definitely better than our base rate, However, we will now experiment with a different method to see if we can increase our results\n\n\n\n\n\nfrom itertools import combinations\nimport numpy as np\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.model_selection import cross_val_score\n\nimport numpy as np \n# these are not actually all the columns: you'll \n# need to add any of the other ones you want to search for\nall_qual_cols = [\"Sex\",\"Clutch Completion\",\"Island\"]\nall_quant_cols = ['Culmen Length (mm)', 'Culmen Depth (mm)', 'Flipper Length (mm)', \"Body Mass (g)\", \"Delta 15 N (o/oo)\"]\n\nbest_col= []\nbest_score = -np.inf\n\nmaximum=np.inf\n\nfor qual in all_qual_cols: \n  qual_cols = [col for col in X_train.columns if qual in col ]\n  for pair in combinations(all_quant_cols, 2):\n    cols = qual_cols + list(pair) \n    for depth in range(2,25):\n        clf = DecisionTreeClassifier(max_depth = depth)\n        scores = cross_val_score(clf, X_train[cols], y_train, cv=4)\n        if scores.mean()>best_score:\n            best_score = scores.mean()\n            best_col= cols\n            maximum = depth\nprint(best_col, best_score, maximum)\n\n        \n\n['Island_Biscoe', 'Island_Dream', 'Island_Torgersen', 'Culmen Length (mm)', 'Culmen Depth (mm)'] 0.984375 4\n\n\nSimilar to the method above, we begin by iterating through all combinations of attributes. Next we use cross validation to determine the best value for maximum depth. We keep track of the best attributes, score and depth.\n\nmodel = DecisionTreeClassifier(max_depth = maximum)\nmodel.fit(X_train[sorted(best_col)],y_train)\nmodel.score(X_test[sorted(best_col)], y_test).round(3)\n\n0.985\n\n\nWe trained a final model with our optimal parameters and tested it our test data. The final model predicted the correct penguin species 98.5% of the time. This is better than the base rate as well as the SVC model. We will now dive further into the accruacy of this model\n\nWe will look at a confusion matrix to see what our accuracy loss is originating. As we can see below, the model preformed accrurate on all but one penguin. This penguin was species1 however our model predicted that it was a species 2 penguin.\n\nfrom sklearn.metrics import confusion_matrix\ny_pred = model.predict(X_test[sorted(best_col)])\n\nconfusion_matrix(y_test, y_pred)\n\narray([[32,  1,  0],\n       [ 0, 12,  0],\n       [ 0,  0, 23]])\n\n\n\n\n\n\n\nfrom matplotlib import pyplot as plt\nimport numpy as np\n\n\nfrom matplotlib.patches import Patch\n\ndef plot_regions(model, X, y):\n    \n    x0 = X[X.columns[0]]\n    x1 = X[X.columns[1]]\n    qual_features = X.columns[2:]\n    \n    fig, axarr = plt.subplots(1, len(qual_features), figsize = (7, 3))\n\n    # create a grid\n    grid_x = np.linspace(x0.min(),x0.max(),501)\n    grid_y = np.linspace(x1.min(),x1.max(),501)\n    xx, yy = np.meshgrid(grid_x, grid_y)\n    \n    \n    XX = xx.ravel()\n    YY = yy.ravel()\n\n    for i in range(len(qual_features)):\n      XY = pd.DataFrame({\n          X.columns[0] : XX,\n          X.columns[1] : YY\n      })\n\n      for j in qual_features:\n        XY[j] = 0\n\n      XY[qual_features[i]] = 1\n\n      p = model.predict(XY)\n      p = p.reshape(xx.shape)\n      \n      \n      # use contour plot to visualize the predictions\n      axarr[i].contourf(xx, yy, p, cmap = \"jet\", alpha = 0.2, vmin = 0, vmax = 2)\n      \n      ix = X[qual_features[i]] == 1\n \n      # plot the data\n      axarr[i].scatter(x0[ix], x1[ix], c = y[ix], cmap = \"jet\", vmin = 0, vmax = 2)\n      \n      axarr[i].set(xlabel = X.columns[0], \n            ylabel  = X.columns[1])\n      \n      patches = []\n      for color, spec in zip([\"red\", \"green\", \"blue\"], [\"Adelie\", \"Chinstrap\", \"Gentoo\"]):\n        patches.append(Patch(color = color, label = spec))\n\n      plt.legend(title = \"Species\", handles = patches, loc = \"best\")\n      \n      plt.tight_layout()\n\n\n\nplot_regions(model,X_train[sorted(best_col)],y_train)\n\n\n\n\nThe plots above visualize our decision regions for the decision tree model. We can see that our model does a pretty good job at separating the different species; however, the middle plot has some samples right on the edge\n\n\n\n\nThis blog post allowed me to practice a machine learning workflow and get hands on experience implementing a classifier with real data. I really enjoyed exploring the different classification models and optimization parameters. I also enjoyed working with real life data, I can really see how this will help me in my future!"
  },
  {
    "objectID": "posts/Data cleaning and prep/final_jupyter_nb.html",
    "href": "posts/Data cleaning and prep/final_jupyter_nb.html",
    "title": "Urban Air Pollution Predicted by Income and Racial Demographics Prep",
    "section": "",
    "text": "from sklearn.model_selection import train_test_split\nimport pandas as pd\nimport numpy as np\nfrom sklearn.linear_model import LogisticRegression\nfrom matplotlib import pyplot as plt\n\nimport plotly.express as px \nimport plotly.io as pio\npio.templates.default = \"plotly_white\"\n\n#check against other studies, check p values \n\n\nimport warnings\nwarnings.filterwarnings('ignore')\n\n%load_ext autoreload\n%autoreload 2\n\n\n\n\nfrom dataCleaning import DatasetClass\n\nds = DatasetClass()\n\ndataset = pd.read_csv(\"pollution_income_race.csv\")\n\nX_train, X_test, y_train, y_test = ds.train_test_data(dataset)\n\nbase_rate = y_test.mean()\n\nbase_rate\n\n0.8605200945626478\n\n\n\nX_train\n\n\n\n\n\n  \n    \n      \n      State Code\n      County Code\n      Date Local\n      Median Household Income\n      Total Pop\n      Total Male %\n      Total Female %\n      White Alone (M) %\n      White Alone (F) %\n      Black Alone (M) %\n      Black Alone (F) %\n      Am Indian+AK Native Alone (M) %\n      Am Indian+AK Native Alone (F) %\n      Asian Alone (M) %\n      Asian Alone (F) %\n      Nat. HI and PI (M) %\n      Nat. HI and PI (F) %\n      TOM_MALE\n    \n  \n  \n    \n      66\n      6\n      1\n      2002\n      113518.0\n      10021506\n      0.495390\n      0.504610\n      0.244432\n      0.238668\n      0.051896\n      0.056041\n      0.005613\n      0.005458\n      0.161241\n      0.171451\n      0.004578\n      0.004916\n      0.027631\n    \n    \n      835\n      32\n      3\n      2001\n      62496.0\n      13662646\n      0.500808\n      0.499192\n      0.349270\n      0.334776\n      0.065935\n      0.068644\n      0.006304\n      0.006135\n      0.048658\n      0.058518\n      0.004651\n      0.004758\n      0.025988\n    \n    \n      67\n      6\n      1\n      2003\n      113518.0\n      10021506\n      0.495390\n      0.504610\n      0.244432\n      0.238668\n      0.051896\n      0.056041\n      0.005613\n      0.005458\n      0.161241\n      0.171451\n      0.004578\n      0.004916\n      0.027631\n    \n    \n      447\n      6\n      95\n      2001\n      83678.0\n      2716962\n      0.501149\n      0.498851\n      0.300509\n      0.288954\n      0.074948\n      0.072824\n      0.006718\n      0.006442\n      0.076265\n      0.088328\n      0.005441\n      0.005261\n      0.037269\n    \n    \n      217\n      6\n      37\n      2012\n      75624.0\n      59665436\n      0.495714\n      0.504286\n      0.353743\n      0.349500\n      0.042930\n      0.046823\n      0.007591\n      0.007220\n      0.073381\n      0.082331\n      0.001828\n      0.001838\n      0.016241\n    \n    \n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n      ...\n    \n    \n      1133\n      42\n      69\n      2002\n      56911.0\n      1294150\n      0.489517\n      0.510483\n      0.437606\n      0.461313\n      0.024152\n      0.021254\n      0.001740\n      0.001697\n      0.016049\n      0.016100\n      0.000323\n      0.000383\n      0.009646\n    \n    \n      1184\n      42\n      101\n      2005\n      55102.0\n      9562106\n      0.475856\n      0.524144\n      0.218985\n      0.226435\n      0.200090\n      0.235551\n      0.004473\n      0.004774\n      0.037813\n      0.041240\n      0.000867\n      0.000898\n      0.013629\n    \n    \n      1219\n      42\n      133\n      2000\n      71655.0\n      2743046\n      0.497499\n      0.502501\n      0.438321\n      0.443527\n      0.037588\n      0.036162\n      0.002079\n      0.001843\n      0.007190\n      0.008613\n      0.000395\n      0.000416\n      0.011926\n    \n    \n      924\n      36\n      103\n      2002\n      109084.0\n      9152726\n      0.495513\n      0.504487\n      0.416442\n      0.422438\n      0.043497\n      0.045976\n      0.003550\n      0.003241\n      0.021259\n      0.022082\n      0.000557\n      0.000519\n      0.010207\n    \n    \n      1215\n      42\n      129\n      2005\n      59349.0\n      2123436\n      0.493617\n      0.506383\n      0.464779\n      0.479903\n      0.014620\n      0.012278\n      0.000807\n      0.000656\n      0.004862\n      0.005320\n      0.000122\n      0.000111\n      0.008428\n    \n  \n\n858 rows × 18 columns\n\n\n\n\n\n\nFeature importance determines how much each feature impacts the AQI when increased by one factor with all other features held constant. What we find below determining feature importance in our data set is that each feature has a relatively low impact on AQI. As we continue training models, however, it is clear that these features together have a significant impact on AQI as they can predict AQI outcome with remarkable accuracy.\n\nfrom sklearn.ensemble import RandomForestClassifier\n\ndef feature_importance(X_train, y_train):\n    \"\"\"\n    This function determines the feature importance of each feature in the dataset and sorts them\n    by importance using Random Forest and Gini import.\n    \"\"\"\n    \n    RF = RandomForestClassifier()\n    RF.fit(X_train, y_train)\n\n    #get importance\n    importances = pd.DataFrame(data = \n                               {'Attribute': X_train.columns,\n                                'Importance': RF.feature_importances_\n                               })\n\n    importances.sort_values('Importance')\n    \n    return importances\n\nimportances = feature_importance(X_train, y_train)\n\nBelow we see the results of the first 10 most important features; Date Local is the feature with the most impact on the AQI, followed by Median Household Income, State Code, Total Male % and then Total Female %. However, it is important to note that most feature importances are below approximately .005.\n\n#plotting the importances in two batches\n\n#first batch\nimportances10 = importances[0:10]\nplt.barh(y=importances10['Attribute'], width=importances10['Importance'], color='#087E8B')\nplt.title(\"Top 10 Features by Importance in Predicting AQI\")\n\nText(0.5, 1.0, 'Top 10 Features by Importance in Predicting AQI')\n\n\n\n\n\nBelow we see the results of the final 8 features and their importances, all of which have very miniscule feature importance values. However, the next most important features all have to do with racial and ethnic demographics.\n\n#second 8\nimportances20 = importances[10:18]\nplt.barh(y=importances20['Attribute'], width=importances20['Importance'], color='#087E8B')\nplt.title(\"11th-18th Most Important Features in Predicting AQI\")\n\nText(0.5, 1.0, '11th-18th Most Important Features in Predicting AQI')\n\n\n\n\n\n\n\n\n\n\n\nfrom sklearn.linear_model import LogisticRegression \n\nLR = LogisticRegression()\nLR.fit(X_train, y_train)\n\nprint(\"Training Accuracy:\")\nprint(LR.score(X_train, y_train))\n\nprint(\"Testing Accuracy:\")\nprint(LR.score(X_test, y_test))\n\n\nTraining Accuracy:\n0.8916083916083916\nTesting Accuracy:\n0.8605200945626478\n\n\n\n\n\n\nfrom sklearn.preprocessing import PolynomialFeatures\nfrom sklearn.pipeline import Pipeline\n\ndef poly_LR(degree, **kwargs):\n    plr = Pipeline([(\"poly\", PolynomialFeatures(degree = degree)),\n                    (\"LR\", LogisticRegression(**kwargs))])\n    return plr\n\n    \nplr = poly_LR(degree = 2, max_iter = 1000000)\nplr.fit(X_train, y_train)\nprint(\"Training accuracy\")\nprint(plr.score(X_train, y_train))\n\nprint(\"Testing accuracy\")\nprint(plr.score(X_test, y_test))\n\n# check p values for statistical significance\n\nTraining accuracy\n0.8916083916083916\nTesting accuracy\n0.8605200945626478\n\n\n\nprint(\"coefficients of model:\")\nprint()\nprint(plr.named_steps['LR'].coef_)\n\nprint(\"biases of model:\")\nprint(plr.named_steps['LR'].intercept_)\n\ncoefficients of model:\n\n[[ 1.11276049e-23  2.70910398e-22  8.13314987e-22  2.23670684e-20\n   8.26684574e-19  5.39082056e-17  5.49742047e-24  5.63018441e-24\n   4.02195097e-24  4.05052126e-24  7.24190483e-25  7.90383926e-25\n   1.21744623e-25  1.22740132e-25  4.17892468e-25  4.50642155e-25\n   1.62466672e-26  1.60424146e-26  1.95395261e-25  9.71212566e-21\n   2.50700099e-20  5.44539274e-19  1.86454545e-17  1.45297020e-15\n   1.33430573e-22  1.37479824e-22  9.84446728e-23  9.97724228e-23\n   1.94709841e-23  2.14792962e-23  3.46827391e-24  3.52705503e-24\n   7.51825966e-24  8.05513764e-24  3.01250434e-25  2.97962788e-25\n   4.22713223e-24  1.43266830e-19  1.63502000e-18  5.78155511e-17\n   4.15345765e-15  4.01429417e-22  4.11885570e-22  2.88552987e-22\n   2.89759055e-22  6.61993339e-23  7.31387587e-23  6.18024253e-24\n   6.09656620e-24  2.60848784e-23  2.81342168e-23  9.93723991e-25\n   9.77824669e-25  1.34182512e-23  4.49591622e-17  1.66155303e-15\n   1.08558323e-13  1.10500506e-20  1.13170178e-20  8.08389662e-21\n   8.14129212e-21  1.45638400e-21  1.58959645e-21  2.44551325e-22\n   2.46546663e-22  8.39891803e-22  9.05697398e-22  3.26519447e-23\n   3.22418227e-23  3.92674887e-22  6.61244745e-14  4.29264003e-12\n   4.08815969e-19  4.17868605e-19  2.95706079e-19  2.96932342e-19\n   5.12802683e-20  5.58143629e-20  7.55101537e-21  7.53315405e-21\n   3.78513109e-20  4.08672204e-20  1.33712125e-21  1.32296402e-21\n   1.50901738e-20 -5.28658863e-15  2.66261809e-17  2.72820247e-17\n   1.83622140e-17  1.83963709e-17  4.25957653e-18  4.72170679e-18\n   3.68358727e-19  3.65098769e-19  2.58360385e-18  2.72716918e-18\n   9.34460019e-20  9.33720194e-20  9.58981750e-19  2.71681158e-24\n   2.78060890e-24  1.99107317e-24  2.00439402e-24  3.53545372e-25\n   3.85272718e-25  6.03240610e-26  6.07964433e-26  2.07110314e-25\n   2.23334739e-25  8.07456117e-27  7.96878746e-27  9.66840967e-26\n   2.84957551e-24  2.03087780e-24  2.04612724e-24  3.70645111e-25\n   4.05111208e-25  6.14205623e-26  6.19436882e-26  2.10782154e-25\n   2.27307417e-25  8.17210604e-27  8.07362716e-27  9.87111639e-26\n   1.51557445e-24  1.52678208e-24  2.25714898e-25  2.42076340e-25\n   4.01434546e-26  4.02884157e-26  1.35841746e-25  1.46686648e-25\n   5.65389432e-27  5.54558986e-27  6.81447289e-26  1.53949921e-24\n   2.28391354e-25  2.45193625e-25  4.05067222e-26  4.06905004e-26\n   1.34738394e-25  1.45478580e-25  5.61679316e-27  5.51176904e-27\n   6.83586772e-26  8.57859440e-26  9.78042487e-26  4.18078631e-27\n   4.14999729e-27  2.56684716e-26  2.75557490e-26  8.56095847e-28\n   8.67239011e-28  1.13391764e-26  1.11912957e-25  4.30807725e-27\n   4.27218307e-27  2.79523239e-26  2.99685240e-26  9.02381923e-28\n   9.16969423e-28  1.22293461e-26  9.30551427e-27  9.66277486e-27\n   2.89481010e-27  3.11549022e-27  1.72160789e-28  1.58426833e-28\n   3.62733494e-27  1.00428990e-26  2.81972503e-27  3.03328287e-27\n   1.70767871e-28  1.56821478e-28  3.70476254e-27  3.27900863e-26\n   3.52132882e-26  9.65928808e-28  9.75541416e-28  8.94927094e-27\n   3.79065517e-26  1.04978000e-27  1.05971914e-27  9.71378340e-27\n   5.19867671e-29  5.17342386e-29  3.74494641e-28  5.17066089e-29\n   3.70256095e-28  4.24909098e-27]]\nbiases of model:\n[1.11276049e-23]\n\n\n\n\n\n\nfrom sklearn.svm import SVC\nfrom sklearn.model_selection import cross_val_score\n\nsvc = SVC(gamma = \"auto\") \nsvc.fit(X_train, y_train)\n\nprint(\"Training Accuracy:\")\nprint(svc.score(X_train, y_train))\n\nprint(\"Test accuracy\")\nprint(svc.score(X_test, y_test))\n\nTraining Accuracy:\n0.9463869463869464\nTest accuracy\n0.9054373522458629\n\n\n\nbest_score = -np.inf\nbest_gamma = np.inf\n\nfor gammas in 6**(np.arange(-4,4, dtype = float)):\n    svc = SVC(gamma = gammas)\n    scores = cross_val_score(svc, X_train, y_train,cv=8)\n    if scores.mean()>best_score:\n        best_score = scores.mean()\n        best_gamma = gammas\n        \nprint(best_score, best_gamma)\n\n0.9114096573208723 0.027777777777777776\n\n\n\nsvc_model = SVC(gamma = .027777777777777776)\nsvc_model.fit(X_train,y_train)\n\nprint(\"training accuracy\")\nprint(svc_model.score(X_train,y_train))\nprint(\"testing\")\nprint(svc_model.score(X_test,y_test))\n\ntraining accuracy\n0.9358974358974359\ntesting\n0.9054373522458629\n\n\n\n\n\n\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.model_selection import cross_val_score\n\nbest_score = -np.inf\nmaximum = 0\n\nfor depth in range(2,25):\n    tree = DecisionTreeClassifier(max_depth = depth)\n    #scores = cross_val_score(tree, X_train[subset], y_train, cv = 11)\n\n    scores = cross_val_score(tree, X_train, y_train, cv = 9)\n    if scores.mean() > best_score:\n        best_score = scores.mean()\n        maximum = depth\nprint(best_score, maximum)\n\n0.8996954191033139 5\n\n\n\ntree = DecisionTreeClassifier(max_depth = 5)\ntree.fit(X_train,y_train)\nprint(\"training\")\nprint(tree.score(X_train,y_train))\nprint(\"testing\")\nprint(tree.score(X_test,y_test))\n\ntraining\n0.9335664335664335\ntesting\n0.900709219858156\n\n\n\n\n\n\nFirst, let’s explore our data a bit by visualizing the AQI, Median Income, and some racial demographics using maps. (might want this at the begninng of the blog post)\n\nimport pandas as pd\n\ndf = pd.read_csv(\"pollution_income_race.csv\")\ndf = df.dropna()\n\nfrom geomapping import Mapping\nmp = Mapping()\nmp.plot_df(df,\"AQI Total\")\n\n\n\n\n\nmp.plot_df(df, \"Median Household Income\")\n\n\n\n\n\nmp.plot_df(df, \"black_alone_percent\")\n\n\n\n\n\n\n\nNext, let’s visualize our binary predictions compared to the actual AQI (want to label these, zoom, etc)\n\n#creating dataframe with test data, labels, and predictions\nfrom copy import deepcopy\ntest_combined = deepcopy(X_test)\n\ntest_combined[\"Predicted AQI Binary\"] = svc_model.predict(X_test)\ntest_combined[\"Actual AQI Binary\"] = y_test\nX_test.head()\n#plotting predictions\n\nmp.plot_df(test_combined, \"Predicted AQI Binary\")\n\n\n\n\n\n# #plotting actual \nmp.plot_df(test_combined, \"Actual AQI Binary\")\n\n\n\n\n\n\n\nThe overall accuracy of the model was 0.9054373522458629\nTo find the PPV of our model we first need to calculate the number of true positives and false positives. To do so, we compare the predicted labels to the test labels. If the predicted label is 1 and the acutal label is 1, then that is a true positive. If the predicted label is 1 and the true label is 0 that is a false positive.\n\nTP = len((np.where((test_combined[\"Predicted AQI Binary\"]==1) & (test_combined[\"Actual AQI Binary\"]==1))[0]))\nFP = len((np.where((test_combined[\"Predicted AQI Binary\"]==1) & (test_combined[\"Actual AQI Binary\"]==0))[0]))\nPPV = round((TP)/(TP+FP),4)\nprint(\"The positive predictive value of this model is: \" + str(PPV))\n\nThe positive predictive value of this model is: 0.9112\n\n\nThe FPR represents the rate at which a test label of 0 is incorrectly predicted to be 1; or, when a high risk county is predicted to be a low risk count.\nThe FNR represents the rate at which a test label of 1 is incorrectly predicted to be 0.\n\nfrom sklearn.metrics import confusion_matrix\nconf_matrix = confusion_matrix(test_combined[\"Actual AQI Binary\"],test_combined[\"Predicted AQI Binary\"], normalize = 'true')\nprint(\"FPR = \" + str(conf_matrix[0][1]))\nprint(\"FNR = \" + str(conf_matrix[1][0])) \n\nFPR = 0.5932203389830508\nFNR = 0.013736263736263736\n\n\n\n\n\nFirst we will divide the data set into high income and low income counties. Counties where the median household incomw is more than $73,125 (mean) will be marked as high income (1) and under this threshold will be marked a lower income (0)\n\ntest_combined.loc[test_combined[\"Median Household Income\"] <=73125,\"High Income\"]=0\ntest_combined.loc[test_combined[\"Median Household Income\"] >73125,\"High Income\"]=1\nmedIncome = test_combined[\"High Income\"]\n\n\nprint(\"The accuracy for high income counties is \" + str((test_combined[\"Predicted AQI Binary\"]==test_combined[\"Actual AQI Binary\"])[medIncome==1].mean().round(4)))\nprint(\"The accuracy for low income counties is \" + str((test_combined[\"Predicted AQI Binary\"]==test_combined[\"Actual AQI Binary\"])[medIncome==0].mean().round(4)))\n\nThe accuracy for high income counties is 0.9653\nThe accuracy for low income counties is 0.864\n\n\nNow we will compare some of the accuracy metrics such as the false positive rate and the false negative rate. Ideally, the values for each group will be about equal.\n\nconf_matrix_high_norm = confusion_matrix(test_combined[\"Actual AQI Binary\"][medIncome==1],test_combined[\"Predicted AQI Binary\"][medIncome==1], normalize = 'true')\nprint(\"FPR for high income counties = \" + str(conf_matrix_high_norm[0][1].round(4) * 100))\nprint(\"FNR for high income counties = \" + str(conf_matrix_high_norm[1][0].round(4) *100)) \n\nconf_matrix_low_norm = confusion_matrix(test_combined[\"Actual AQI Binary\"][medIncome==0],test_combined[\"Predicted AQI Binary\"][medIncome==0], normalize = 'true')\nprint(\"FPR for low income counties = \" + str(conf_matrix_low_norm[0][1].round(4) *100))\nprint(\"FNR for low income counties = \" + str(conf_matrix_low_norm[1][0].round(4) *100))\n\nFPR for high income counties = 50.0\nFNR for high income counties = 0.61\nFPR for low income counties = 61.22\nFNR for low income counties = 1.9900000000000002\n\n\n\n\n\nCalibration means that the fraction of predicted counties to have a AQI binary score of 1 (low risk) is the same across all income groups. So we will calculate this metric for both income groups. This metric can be calculated by dividing the number of true positives by the total number of predicted positives.\n\n\nhigh_income_calibration = confusion_matrix(test_combined[\"Actual AQI Binary\"][medIncome==1],test_combined[\"Predicted AQI Binary\"][medIncome==1])[0][0]/(confusion_matrix(test_combined[\"Actual AQI Binary\"][medIncome==1],test_combined[\"Predicted AQI Binary\"][medIncome==1])[0].sum())\nlow_income_calibration = confusion_matrix(test_combined[\"Actual AQI Binary\"][medIncome==0],test_combined[\"Predicted AQI Binary\"][medIncome==0])[0][0]/(confusion_matrix(test_combined[\"Actual AQI Binary\"][medIncome==0],test_combined[\"Predicted AQI Binary\"][medIncome==0])[0].sum())\n\nprint(\"The percentage of high income counties predicted to have a low risk AQI who actually had a low risk AQI is \" + str(high_income_calibration.round(4)*100))\nprint(\"The percentage of low income counties predicted to have a low risk AQI who actually had a low risk AQI is \" + str(low_income_calibration.round(4)*100))\n\n\n\nThe percentage of high income counties predicted to have a low risk AQI who actually had a low risk AQI is 50.0\nThe percentage of low income counties predicted to have a low risk AQI who actually had a low risk AQI is 38.78\n\n\nThis model is not calibrated as the percentages are very different. There is a 11.2% difference\nA model satisfies error rate balance if the false positive and false negative rates are equal across groups. Looking at the previously calculated FPR anf FNR, I would say that this model does not satisfy error rate balance. The FPR for high income counties is 50%, while the FPR for low income counties is 61.22%. The difference between the two rates is 10.1%. In general, the high FPR may stem from a lack of positive observation in the training data itself.\nA model satisifes statistical parity if the proportion of counties classified as having a low risk AQI is the same for each group. So we compare the total number of predicted positives.\n\nprint(\"The proportion of low income counties classified as having a low risk AQI is \" + str((confusion_matrix(test_combined[\"Actual AQI Binary\"][medIncome==0],test_combined[\"Actual AQI Binary\"][medIncome==0])[0].sum())/(medIncome==0).sum()))\nprint(\"The proportion of high income counties classified as having a low risk AQI is \" + str((confusion_matrix(test_combined[\"Actual AQI Binary\"][medIncome==1],test_combined[\"Actual AQI Binary\"][medIncome==1])[0].sum())/(medIncome==1).sum()))\n\n\nThe proportion of low income counties classified as having a low risk AQI is 0.196\nThe proportion of high income counties classified as having a low risk AQI is 0.057803468208092484\n\n\nThis model does not satisfy statistical parity. The proportion of counties predictied to have a low risk AQI is not the same for low and high income areas. The is a 14% difference between the two groups.\n\n\n\nThe data set will first be split into two halves. One set of counties is designated (1), where white people make up the majority of its residents. Additionally, counties without a significant white majority are denoted with a 0.\n\ntest_combined.loc[(test_combined[\"White Alone (M) %\"]+test_combined[\"White Alone (F) %\"])<=.50,\"Majority White\"]=0\ntest_combined.loc[(test_combined[\"White Alone (M) %\"]+test_combined[\"White Alone (F) %\"])>.50,\"Majority White\"]=1\n\nmajority_white = test_combined[\"Majority White\"]\n                                                 \n                                                 \n\n\nprint(\"The accuracy for counties with a white majority population is \" + str((test_combined[\"Predicted AQI Binary\"]==test_combined[\"Actual AQI Binary\"])[majority_white==1].mean().round(4)))\nprint(\"The accuracy for counties without a white majority population is \" + str((test_combined[\"Predicted AQI Binary\"]==test_combined[\"Actual AQI Binary\"])[majority_white==0].mean().round(4)))\n\nThe accuracy for counties with a white majority population is 0.9122\nThe accuracy for counties without a white majority population is 0.8511\n\n\nNow we will compare some of the accuracy metrics such as the false positive rate and the false negative rate. Ideally the metrics will be about equal across the different demographic groups\n\nconf_matrix_major_white_norm = confusion_matrix(test_combined[\"Actual AQI Binary\"][majority_white==1],test_combined[\"Predicted AQI Binary\"][majority_white==1], normalize = 'true')\nprint(\"FPR for counties with a majority white population = \" + str(conf_matrix_major_white_norm[0][1].round(4) ))\nprint(\"FNR for counties with a majority white population = \" + str(conf_matrix_major_white_norm[1][0].round(4))) \n\nconf_matrix_nonmajor_white_norm = confusion_matrix(test_combined[\"Actual AQI Binary\"][majority_white==0],test_combined[\"Predicted AQI Binary\"][majority_white==0], normalize = 'true')\nprint(\"FPR for counties without a majority white population = \" + str(conf_matrix_low_norm[0][1].round(4)))\nprint(\"FNR for counties without a majority white population = \" + str(conf_matrix_low_norm[1][0].round(4)))\n\nFPR for counties with a majority white population = 0.58\nFNR for counties with a majority white population = 0.0123\nFPR for counties without a majority white population = 0.6122\nFNR for counties without a majority white population = 0.0199\n\n\n\n\n\nCalibration means that the fraction of predicted counties to have a AQI binary score of 1 (low risk) is the same across all demographic groups. So we will calculate this metric for both demographics groups. This metric can be calculated by dividing the number of true positives by the total number of predicted positives.\n\nmajority_calibration = confusion_matrix(test_combined[\"Actual AQI Binary\"][majority_white==1],test_combined[\"Predicted AQI Binary\"][majority_white==1])[0][0]/(confusion_matrix(test_combined[\"Actual AQI Binary\"][majority_white==1],test_combined[\"Predicted AQI Binary\"][majority_white==1])[0].sum())\nnonmajority_calibration = confusion_matrix(test_combined[\"Actual AQI Binary\"][majority_white==0],test_combined[\"Predicted AQI Binary\"][majority_white==0])[0][0]/(confusion_matrix(test_combined[\"Actual AQI Binary\"][majority_white==0],test_combined[\"Predicted AQI Binary\"][majority_white==0])[0].sum())\n\nprint(\"The percentage of counties without a majority white population predicted have a low risk AQI who actually had a low risk AQI is \" + str(nonmajority_calibration.round(4)*100))\nprint(\"The percentage of counties with a majority white population predicted have a low risk AQI who actually had a low risk AQI is \" + str(majority_calibration.round(4)*100))\n\nThe percentage of counties without a majority white population predicted have a low risk AQI who actually had a low risk AQI is 33.33\nThe percentage of counties with a majority white population predicted have a low risk AQI who actually had a low risk AQI is 42.0\n\n\nThis model is not calibrated as the percentages are very different. There is a 9% difference\nA model satisfies error rate balance if the false positive and false negative rates are equal across groups. Looking at the previously calculated FPR anf FNR, I would say that this model does not satisfy error rate balance. The FPR for counties with a majority white population is 58%, while the FPR for counties without a majority white population is 61%.\nA model satisifes statistical parity if the proportion of counties classified as having a low risk AQI is the same for each group. So we compare the total number of predicted positives.\n\nprint(\"The proportion of counties with a majority white population classified as having a low risk AQI is \" + str((confusion_matrix(test_combined[\"Actual AQI Binary\"][majority_white==1],test_combined[\"Actual AQI Binary\"][majority_white==1])[0].sum())/(majority_white==1).sum()))\nprint(\"The proportion of counties without a majority white population classified as having a low risk AQI is \" + str((confusion_matrix(test_combined[\"Actual AQI Binary\"][majority_white==0],test_combined[\"Actual AQI Binary\"][majority_white==0])[0].sum())/(majority_white==0).sum()))\n\nThe proportion of counties with a majority white population classified as having a low risk AQI is 0.13297872340425532\nThe proportion of counties without a majority white population classified as having a low risk AQI is 0.19148936170212766\n\n\nThese values are roughly the same, so I would say that this model satisfies statistical parity."
  },
  {
    "objectID": "posts/Gradient Descent Blog Post/Gradient_Descent_blog.html",
    "href": "posts/Gradient Descent Blog Post/Gradient_Descent_blog.html",
    "title": "Gradient Descent",
    "section": "",
    "text": "We are looking at the use of gradient descent for optimization and the logistic loss problem. In this assignment I implement gradient descent for logistic regression, implement stochastic gradient descent and perform several experiments that test the limits of the algorithms\nlink to gradient descent code\n\n\n\n\nimport importlib\nimport gradient_descent\nfrom gradient_descent import LogisticRegression \n\n%load_ext autoreload\n%autoreload 2\n\nfrom sklearn.datasets import make_blobs, make_circles\nfrom matplotlib import pyplot as plt\nimport numpy as np\nnp.seterr(all='ignore') \n\n{'divide': 'warn', 'over': 'warn', 'under': 'ignore', 'invalid': 'warn'}"
  },
  {
    "objectID": "posts/Gradient Descent Blog Post/Gradient_Descent_blog.html#stochastic-descent",
    "href": "posts/Gradient Descent Blog Post/Gradient_Descent_blog.html#stochastic-descent",
    "title": "Gradient Descent",
    "section": "Stochastic Descent",
    "text": "Stochastic Descent\n\nnp.random.seed(8674)\n\nX2, y2 = make_blobs(n_samples = 100, n_features = p_features-1,centers=[(-1.7,-1.7),(1.7,1.7)])\n\nfig2 = plt.scatter(X2[:,0], X2[:,1], c = y2)\nxlab = plt.xlabel(\"Feature 1\")\nylab = plt.ylabel(\"Feature 2\")\n\n\n\n\n\nLR2 = LogisticRegression()\nLR2.fit_stochastic(X2, y2, alpha = 0.1, max_epochs = 1000, batch_size = 15)\n\nThe Stochastic fit function beginns similiarly to the original gradient descent function: > - create X_ > - generate random weight vector of size features+1 > - set previous loss = infinity\nThen we have to iterate thrugh the following for the number of max epochs or until the loss converges:\n\n\nshuffle the points randomly\npick the first random k points and update the weights vector using the stochastic gradient\npick the next set of random points and repeat\nupdate the loss and score history\nreshuffle the points randomly and iterate again\n\n\n\n\nthe gradient function is the same as the original one, we are just inputting a subset of X_ and y_ into the function repeatedly\n\n\n\nfig2 = plt.scatter(X2[:,0], X2[:,1], c = y2)\nfig2 = draw_line(LR2.w, -2, 2)\n\nxlab = plt.xlabel(\"Feature 1\")\nylab = plt.ylabel(\"Feature 2\")\n\n\n\n\n\nprint(LR2.loss_history[-3])\nprint(LR2.loss_history[-2])\nprint(LR2.loss_history[-1])\nprint(LR2.score_history[-1])\n\n0.0033704921863074765\n0.003368276616639715\n0.0033660810616696095\n1.0\n\n\nThis is a good separator as our loss is close to 0 and our score is close to 1"
  },
  {
    "objectID": "posts/Gradient Descent Blog Post/Gradient_Descent_blog.html#comparing-methods",
    "href": "posts/Gradient Descent Blog Post/Gradient_Descent_blog.html#comparing-methods",
    "title": "Gradient Descent",
    "section": "Comparing methods",
    "text": "Comparing methods\n\nLR = LogisticRegression()\nLR.fit_stochastic(X2, y2, \n                  max_epochs = 10000, \n             \n                  batch_size = 10, \n                  alpha = .05) \n\nnum_steps = len(LR.loss_history)\nplt.plot(np.arange(num_steps) + 1, LR.loss_history, label = \"stochastic gradient (a=0.05)\")\n\nLR = LogisticRegression()\nLR.fit_stochastic(X2, y2, \n                  max_epochs = 10000, \n                  batch_size = 10, \n                  alpha = .1)\n\nnum_steps = len(LR.loss_history)\nplt.plot(np.arange(num_steps) + 1, LR.loss_history, label = \"stochastic gradient a = .1\")\n\nLR = LogisticRegression()\nLR.fit(X2, y2, alpha = .05, max_epochs = 10000)\n\nnum_steps = len(LR.loss_history)\nplt.plot(np.arange(num_steps) + 1, LR.loss_history, label = \"gradient\")\n\nplt.loglog()\n\nlegend = plt.legend() \n\n\n\n\nFor these settings, we can see that the stochastic methods are performing much better than the regular gradient descent method. All three methods have a smooth decline in loss, but the stochastic gradient seems to have had the fastest decline. I believe the the gradient methods would need more epochs to find a better solution."
  },
  {
    "objectID": "posts/Gradient Descent Blog Post/Gradient_Descent_blog.html#experiment-alpha-is-too-large",
    "href": "posts/Gradient Descent Blog Post/Gradient_Descent_blog.html#experiment-alpha-is-too-large",
    "title": "Gradient Descent",
    "section": "Experiment: alpha is too large",
    "text": "Experiment: alpha is too large\n\nnp.random.seed(4001)\n\nn = 100\np_features = 3\n\nX3, y3 = make_blobs(n_samples = 100, n_features = p_features-1,centers=[(-1.7,-1.7),(1.7,1.7)])\n\nfig1 = plt.scatter(X3[:,0], X3[:,1], c = y3)\nxlab = plt.xlabel(\"Feature 1\")\nylab = plt.ylabel(\"Feature 2\")\n\n\n\n\n\n#alpha is too large\nLR3 = LogisticRegression()\nLR3.fit(X3, y3, alpha = 200, max_epochs = 10000)\n\n#alpha is a normal value\nLR5 = LogisticRegression()\nLR5.fit(X3, y3, alpha = .01, max_epochs = 10000)\n\n\n\n#alpha = 200\nfig3 = plt.scatter(X3[:,0], X3[:,1], c = y3)\nfig3 = draw_line(LR3.w, -2, 2)\n\nxlab = plt.xlabel(\"Feature 1\")\nylab = plt.ylabel(\"Feature 2\")\nLR3.loss_history\nLR3.w\n\narray([125.42362443, 123.04901387, -14.35961152])\n\n\n\n\n\n\n#alpha = .01\nfig3 = plt.scatter(X3[:,0], X3[:,1], c = y3)\nfig3 = draw_line(LR5.w, -2, 2)\n\nxlab = plt.xlabel(\"Feature 1\")\nylab = plt.ylabel(\"Feature 2\")\n\n\n\n\n\n\nnum_steps1 = len(LR3.loss_history)\nplt.plot(np.arange(num_steps1) + 1, LR3.loss_history, label = \"(a=200)\")\n\nnum_steps2 = len(LR5.loss_history)\nplt.plot(np.arange(num_steps2) + 1, LR5.loss_history, label = \"a =.01\")\n\n\n\n\nlegend = plt.legend() \n\n\n\n\nWe can see that both alphas result in good separators. But, we have discovered one of the caveats of logistic regression. It can combat alphas that are too large by increasing all of the weights. So, for data that is linearly separable the model performs as good as you want it to. Hence, we will now investigate non-linearly separable data\n\nNon linearly separable\n\nnp.random.seed(8680)\n\nn = 100\np_features = 4\n\nX4, y4 = make_blobs(n_samples = 100, n_features = p_features-1,centers=[(-1,-1),(1,1)])\n\n\n\nfig1 = plt.scatter(X4[:,0], X4[:,1], c = y4)\nxlab = plt.xlabel(\"Feature 1\")\nylab = plt.ylabel(\"Feature 2\")\n\n\n\n\n\nLR6 = LogisticRegression()\nLR6.fit(X4, y4, alpha = 100, max_epochs = 10000)\n\nLR7 = LogisticRegression()\nLR7.fit(X4, y4, alpha = 1, max_epochs = 10000)\n\n\n\nfig3 = plt.scatter(X4[:,0], X4[:,1], c = y4)\nfig3 = draw_line(LR6.w, -2, 2)\n\n\n\n\n\nfig3 = plt.scatter(X4[:,0], X4[:,1], c = y4)\nfig3 = draw_line(LR7.w, -2, 2)\n\n\n\n\n\n\nnum_steps1 = len(LR6.loss_history)\nplt.plot(np.arange(num_steps1) + 1, LR6.loss_history, label = \"(a=100)\")\n\n\nnum_steps1 = len(LR7.loss_history)\nplt.plot(np.arange(num_steps1) + 1, LR7.loss_history, label = \"(a=1)\")\n\n\nlegend = plt.legend() \n\n\n\n\nHere we can see that our model performs fairly well at a smaller alpha (1) as the line mostly separates the data. However, for a larger alpha the algorithm does not work well. It is unable to converge and thus results in a bad separater and the loss bounces around"
  },
  {
    "objectID": "posts/Gradient Descent Blog Post/Gradient_Descent_blog.html#experiment-batch-size",
    "href": "posts/Gradient Descent Blog Post/Gradient_Descent_blog.html#experiment-batch-size",
    "title": "Gradient Descent",
    "section": "Experiment batch size",
    "text": "Experiment batch size\n\nnp.random.seed(8680)\n\nn = 100\np_features = 4\n\nX4, y4 = make_blobs(n_samples = 100, n_features = p_features-1,centers=[(-1.7,-1.7),(1.7,1.7)])\n\n\nLR = LogisticRegression()\nLR.fit_stochastic(X4, y4, \n                  max_epochs = 10000, \n                  batch_size = 8, \n                  alpha = .1) \n\nnum_steps = len(LR.loss_history)\nplt.plot(np.arange(num_steps) + 1, LR.loss_history, label = \"stochastic gradient (batch_size=8)\")\n\nLR = LogisticRegression()\nLR.fit_stochastic(X4, y4, \n                  max_epochs = 10000, \n                  batch_size = 80, \n                  alpha = .1)\n\nnum_steps = len(LR.loss_history)\nplt.plot(np.arange(num_steps) + 1, LR.loss_history, label = \"stochastic gradient (batch_size=80)\")\n\n\nplt.loglog()\n\nlegend = plt.legend() \n\n\n\n\nFor this experiment I compared a stochastic batch size of 8 to a batch size of 80. We can see that a smaller batch size allows the algorithm to converge must faster. Increasing the batch size by a factor of 8 almost increased the number of needed epochs by a factor of 10"
  },
  {
    "objectID": "posts/Linear Regression Blog Post/Linear Regression Blog nb.html",
    "href": "posts/Linear Regression Blog Post/Linear Regression Blog nb.html",
    "title": "Linear Regression",
    "section": "",
    "text": "link to source code"
  },
  {
    "objectID": "posts/Linear Regression Blog Post/Linear Regression Blog nb.html#analytic-approach",
    "href": "posts/Linear Regression Blog Post/Linear Regression Blog nb.html#analytic-approach",
    "title": "Linear Regression",
    "section": "Analytic Approach",
    "text": "Analytic Approach\nThe analytic apporach makes use of the definition of convergence during gradient descent. At the minimum, \\(\\nabla L(w) = 0\\). Setting this equal to our expression for \\(\\nabla L(w)\\) gives \\(0 = X^{T}(X~\\hat{w} -y)\\). Solving for \\(\\hat{w}\\) gives \\(\\hat{w} = (X^{T}X)^{-1}X^{T}y\\), which can bed used to directly solve for \\(\\hat{w}\\) assuming X is padded. Now lets test the approach and generate some data\n\np_features = 1.\n\nn_train = 100\nn_val = 100\np_features = 1\nnoise = 0.13\n\n# create some data\nX_train, y_train, X_val, y_val = LR_data(n_train, n_val, p_features, noise)\n\n# plot it\nfig, axarr = plt.subplots(1, 2, sharex = True, sharey = True)\naxarr[0].scatter(X_train, y_train)\naxarr[1].scatter(X_val, y_val)\nlabs = axarr[0].set(title = \"Training\", xlabel = \"x\", ylabel = \"y\")\nlabs = axarr[1].set(title = \"Validation\", xlabel = \"x\")\nplt.tight_layout()\n\n\n\n\nNow that we have our data, let’s train a model with the corresponding training data. For the first step of the function, I padded X_train the plugged it into the equation\n\nLR_analytic = LinearRegression()\n\n\nLR_analytic.fit_analytic(X_train,y_train)\n\nLet’s plot our new model\n\nplt.scatter(X_train,y_train)\nplt.plot(X_train,pad(X_train)@LR_analytic.w, color=\"black\")\n\n\n\n\nWe can see that this model produces a pretty good fit forour data. It roughly follows the positive linear pattern of our data, but let’s look at the scores to get a better idea of performance\n\nprint(f\"Training score = {LR_analytic.score(pad(X_train),y_train).round(4)}\")\nprint(f\"Validation score = {LR_analytic.score(pad(X_val),y_val).round(4)}\")\n\nTraining score = 0.5225\nValidation score = 0.5491\n\n\nOur accuracies are pretty good considering the coefficient of determination is always no larger than 1 and can be arbitrarily negative for very bad models."
  },
  {
    "objectID": "posts/Linear Regression Blog Post/Linear Regression Blog nb.html#gradient-descent-approach",
    "href": "posts/Linear Regression Blog Post/Linear Regression Blog nb.html#gradient-descent-approach",
    "title": "Linear Regression",
    "section": "Gradient Descent Approach",
    "text": "Gradient Descent Approach\nNow let’s look at the gradient descent approach. This approach makes use of the gradient function \\(\\nabla L(w) = 2X^{T}(Xw-y)\\). We use this during the repeadted iteration of \\[w^{(t+1)} \\leftarrow w^{(t)} - 2\\alpha X^{T}(Xw^{(t)} -y)\\] we iterate until we hit the max number of iterations or until the gradient =0. We also track the score over the iterations. Let’s use the same data to compare our results\n\nLR_gradient = LinearRegression()\nLR_gradient.fit_grad(X_train,y_train)\n\n\nplt.scatter(X_train,y_train)\nplt.plot(X_train, pad(X_train)@LR_gradient.w, color=\"black\")\n\n\n\n\nonce again we can see that model does a good job predicting as the resulting line follows the positive linear pattern of the training data. Let’s look at the scores\n\nprint(f\"Training score = {LR_gradient.score(pad(X_train),y_train).round(4)}\")\nprint(f\"Validation score = {LR_gradient.score(pad(X_val),y_val).round(4)}\")\n\nTraining score = 0.5225\nValidation score = 0.5491\n\n\nThese scores are once again pretty good considering the scores max is 1 and can be arbitrarily negative for bad models. It also a good sign that the scores are the same as the analytic approach! Now, let’s look at the score progression.\n\nplt.plot(LR_gradient.score_history)\nlabels = plt.gca().set(xlabel = \"Iteration\", ylabel = \"Score\")\n\n\n\n\nAs expected, we see that our model started off with low accuracy, but quickly achieve a higher accuracy! This is to be expected as linear regression models often do well just after one iteration."
  },
  {
    "objectID": "posts/Linear Regression Blog Post/Linear Regression Blog nb.html#experiments",
    "href": "posts/Linear Regression Blog Post/Linear Regression Blog nb.html#experiments",
    "title": "Linear Regression",
    "section": "Experiments",
    "text": "Experiments\n\np_features_exp = [2,50,100,150,170,180,190,199]\n\nn_train = 200\nn_val = 200\nnoise = 0.1\ntraining_scores=[]\nval_scores=[]\n\n# create some data\n\nfor p in p_features_exp:\n    X_train_exp, y_train_exp, X_val_exp, y_val_exp = LR_data(n_train, n_val, p, noise)\n    # print( X_train_exp[:5])\n    LR_exp1 = LinearRegression()\n    LR_exp1.fit_analytic(X_train_exp,y_train_exp)\n    training_scores.append(LR_exp1.score(pad(X_train_exp),y_train_exp).round(4))\n    val_scores.append(LR_exp1.score(pad(X_val_exp),y_val_exp).round(4))\n\n\n\n\nfig1 = plt.scatter(p_features_exp,training_scores)\nplt.scatter(p_features_exp,val_scores)\nplt.xlabel(\"Number of features\")\nplt.ylabel(\"Score\")\nplt.legend([\"Training\",\"Validation\"])\n\n<matplotlib.legend.Legend at 0x7fa3f7c56820>\n\n\n\n\n\nThis trend makes sense to me. Training a model is fairly easy and thus it is fairly easy to achieve a high accurcay/score for your training data. So, a pretty flat but high training accuracy was expected. The validation score is what matters as it shows how the model will perform on new data. The model starts of with a realtivelhy low vlaidation accuracy and it increases until the number of features is very similar to the number of data points. This is due to over fitting. As more features are added to our data, the model becomes increasingly complex, having to account for more and more properties. While it is complex, the training accruacy is still high as the model was trained on the data that it is evaluating. As we introduce new data (val data) the model has been over fitting the data (increasingly complex to fit the training data), so the model is so complex and specific to the training data that it is not performing well on the validation data."
  },
  {
    "objectID": "posts/Linear Regression Blog Post/Linear Regression Blog nb.html#lasso-regularization",
    "href": "posts/Linear Regression Blog Post/Linear Regression Blog nb.html#lasso-regularization",
    "title": "Linear Regression",
    "section": "LASSO REGULARIZATION",
    "text": "LASSO REGULARIZATION\n\n#importing from scikit learn\n\nfrom sklearn.linear_model import Lasso\nL = Lasso(alpha = 0.001)\n\n\n\np_features_exp2 = [2,50,100,150,170,180,190,199, 210, 220]\n\nn_train2 = 200\nn_val2 = 200\nnoise = 0.1\ntraining_scores2=[]\nval_scores2=[]\n\n# create some data\n\nfor p in p_features_exp2:\n    X_train_exp2, y_train_exp2, X_val_exp2, y_val_exp2 = LR_data(n_train2, n_val2, p, noise)\n\n    L.fit(X_train_exp2,y_train_exp2)\n    training_scores2.append(L.score(X_train_exp2,y_train_exp2).round(4))\n    val_scores2.append(L.score(X_val_exp2,y_val_exp2).round(4))\n\n\nfig2 = plt.scatter(p_features_exp2,training_scores2)\nplt.scatter(p_features_exp2,val_scores2)\nplt.xlabel(\"Number of features\")\nplt.ylabel(\"Score\")\nplt.legend([\"Training\",\"Validation\"])\n\n<matplotlib.legend.Legend at 0x7fa3f8051be0>\n\n\n\n\n\nThe training scores look to be about the same as the scores generated from the linear regression model. That being relatively stable and high. The validation scores show a bit of a different pattern than the scores from purely LR model. In the LR model scores, the val scores remained high until just before p = n. The LASSO regularization model shows more of gradual decrease in validation accuracy. The model seems to hit its validation accuracy peak around p=n/2 and starts a steady decline for larger Ps. However, the validation accuracy for p=n-1 is larger with the LASSO model in comparison to purely LR"
  },
  {
    "objectID": "posts/Perceptron Blog Post/Perceptron Blog.html",
    "href": "posts/Perceptron Blog Post/Perceptron Blog.html",
    "title": "Perceptron Blog Post",
    "section": "",
    "text": "link to perceptron code\n\n\nIn this blog post we will delve into the perceptron algorithm. I have implemented a algorithm that separates binary data. We have also conducted experiments that push the limits of our algorithm and show cases different patterns\n\n\n\n\nimport pandas as pd\nimport numpy as np\nimport seaborn as sns\nfrom matplotlib import pyplot as plt\nfrom sklearn.datasets import make_blobs\n\n\n#importing perceptron.py code and updating\nimport perceptron\nfrom perceptron import Perceptron\nimport importlib\nimportlib.reload(perceptron)\n\n<module 'perceptron' from '/Users/mtarantola@middlebury.edu/Downloads/Machine Learning/miatarantola.github.io/posts/Perceptron Blog Post/perceptron.py'>\n\n\n\n\n\nThe following function is used to update the perceptron weights:\n\n\\(\\tilde{w} ^{(t+1)} = \\tilde{w} ^ {(t)} + \\mathbb{1}(\\tilde{y_i} \\langle \\tilde{w}^{(t)}, \\tilde{x_i} \\rangle < 0) \\tilde{y_i} \\tilde{x_i}\\)\n\nIn order to implement this algorithm, we must follow these steps.\n\\({1.}\\) pick a random index \\(~{i} \\in\\) n. \n\\({2. }\\) predict the label, \\(\\hat{y_i}\\), of our randomly selected data point, \\(\\tilde{x_i}\\).\n\nTo do so we calculate the dot product, \\(\\langle \\tilde{w}^{(t)}, \\tilde{x_i} \\rangle\\) and compare the resulting value to 0.\n\n\nif the result is greater than 0 return 1, otherwise return -1.\n\n\\({3.}\\) compute \\(\\mathbb{1}(\\tilde{y_i} \\langle \\tilde{w}^{(t)}, \\tilde{x_i} \\rangle < 0)\\)\n\nGiven our predicted label, \\(\\hat{y_i}\\) , of 1 or -1 we can multiply by \\(\\tilde{y_i}\\) to check for correctness\n\n\nIf \\(\\hat{y_i} \\tilde{y_i} <0\\) then the signs of our observed and predicted label do not match. If \\(\\hat{y_i} \\tilde{y_i} >0\\) then the signs of our predicted and observed label match\n\nSo, \\(\\mathbb{1}(\\tilde{y_i} \\langle \\tilde{w}^{(t)}, \\tilde{x_i} \\rangle < 0)\\) returns 1 if model predicted incorrectly and \\(\\tilde{y_i} \\tilde{x_i}\\) is added to the pre-existing weights.\nOtherwise the expression returns 0 for a correctly prediction and no update is performed\n\n\n\n\n\n\nnp.random.seed(8674)\n\nn = 100\np_features = 3\n\nX1, y1 = make_blobs(n_samples = 100, n_features = 2,centers=[(-1.7,-1.7),(1.7,1.7)])\n\nfig1 = plt.scatter(X1[:,0], X1[:,1], c = y1)\nxlab = plt.xlabel(\"Feature 1\")\nylab = plt.ylabel(\"Feature 2\")\n\n\n\n\n\np1 = Perceptron()\n\n\np1.fit(X1,y1,100000)\n\n\nfig1 = plt.plot(p1.history)\nxlab = plt.xlabel(\"Iteration\")\nylab = plt.ylabel(\"Accuracy\")\n\n\n\n\n\np1.score(X1,y1)\n\n1.0\n\n\n\ndef draw_line(w, x_min, x_max):\n  x = np.linspace(x_min, x_max, 101)\n  y = -(w[0]*x + w[2])/w[1]\n  plt.plot(x, y, color = \"black\")\n\nfig = plt.scatter(X1[:,0], X1[:,1], c = y1)\nfig = draw_line(p1.w, -2, 2)\n\nxlab = plt.xlabel(\"Feature 1\")\nylab = plt.ylabel(\"Feature 2\")\n\n\n\n\nFor this experiment we ran our perceptron algorithm on linearly separable data. We can see that the reuslting line is a good separator as it clearly separates our two labels. It is interesting to see that the accuracy decreases before it increases. Another result that suggests our separator is a good fit is that our algorithm stops before the maximum number of iterations allowed\n\n\n\nnp.random.seed(7810) #7810\n\nn = 100\np_features = 3\n\nX2, y2 = make_blobs(n_samples = 100,n_features=2, centers=2)\n\nfig2 = plt.scatter(X2[:,0], X2[:,1], c = y2)\nxlab = plt.xlabel(\"Feature 1\")\nylab = plt.ylabel(\"Feature 2\")\n\n\n\n\n\np2 = Perceptron()\n\n\np2.fit(X2,y2,1000)\n\n\nfig3 = plt.plot(p2.history)\nxlab = plt.xlabel(\"Iteration\")\nylab = plt.ylabel(\"Accuracy\")\n\n\n\n\n\np2.score(X2,y2)\n\n0.5\n\n\n\nfig = plt.scatter(X2[:,0], X2[:,1], c = y2)\nfig = draw_line(p2.w, -2, 2)\n\nxlab = plt.xlabel(\"Feature 1\")\nylab = plt.ylabel(\"Feature 2\")\n\n\n\n\nThis experiment displays the use of our perceptron algorithm on nonlinearly separable data. As shown above, the resulting line is not a good separater. In fact, it isn’t separating any data. We can also see the inaccuracy by tracking the accuracy over iterations. We can see that the algorihtm is not converging to one set of weights and thus has not found an optimizer.\n\n\n\n\nnp.random.seed(7810) #7810\n\nn = 100\n\nX3, y3 = make_blobs(n_samples = 100,n_features=6, centers=2)\n\n\np3 = Perceptron()\n\n\np3.fit(X3,y3,1000)\n\n\nfig4 = plt.plot(p3.history)\nxlab = plt.xlabel(\"Iteration\")\nylab = plt.ylabel(\"Accuracy\")\n\n\n\n\n\np3.score(X3,y3)\n\n1.0\n\n\nYes, I do believe that my data is linearly separable because my perceptron’s accuracy converges to 1 after 18 iterations. This means that my perceptron reached 100% accuracy and did not complete upon reaching that maximum number of iterations.\n\n\n\n\nThe time complexity for a single iteration of the perceptron algorithm is O(p) because predicting the label of a single data point requires calculating the dot product of x and w. Thus, np iterates over the p features of x to calulate the dot product. All other steps of this equation invlove simple multiplication or addition which are O(1)."
  },
  {
    "objectID": "posts/Timnit Gebru Blog Post/Timnit Gebru NB.html",
    "href": "posts/Timnit Gebru Blog Post/Timnit Gebru NB.html",
    "title": "Learning from Timnit Gebru",
    "section": "",
    "text": "Mia Tarantola\n\n\nThis blog post will contain two parts. The first portion will be completed prior to our talk and will be based on self guided research on our speaker Timnit Gebru. I will take notes and pose some thoughtful questions that I think will make for a good discussion.\nThe second portion will be completed during/after Gebru’s talk. I will take notes and reflect on the material.\nDr. Timnit Gebru is a successful American computer scientist who focuses on artificial intelligence and algorithmic bias. She has become a well known advocated for diversity in technology and even founded her own community , Black in AI. In December 2020 Gebru left her position as the Ethical Artificial Intelligence Team lead at Google, following pushback fron her as-yet unpuclished paper voicing her concerns on the dangerous biases of large language models.\n\n\n\n\n\nrecording of the talk\nTimnit Gebru’s talk on “Computer Vision in practice: who is benefitting and who is being harmed?” focuses on the ethical ramifications of computer vision technology in our society. Grebru emphasizes the need for critical thought on the possible effects of new technologies on marginalized communities as a top researcher in artifical intelligence and ethics.\nGebru’s talk emphasizes the danger that can result from the use of computer vision technology when it is implemented without adequate consideration of the potential consequences. She discusses how face recognition technology may be used to mistakenly identify people based on their gender and skin color, potentially leading to false charges and arrests. Additionally, predictive policing systems that rely on biased data sets can perpetuate systemic discrimination against communities of color, leading to increased surveillance and targeting. The ethics of data collecting and utilization are also covered by Gebru. She emphasizes that a model’s deployment might still be unethical even if its accuracy is identical among all groups. Images scraped from numerous online sources are frequently included in data sets, often without the subjects’ knowledge. She says that people are unlikely to want their pictures to be used in face recognition software to identify protesters.\nGebru argues that it is essential for individuals who create and use computer vision systems to take into account these possible negative effects and strive toward creating more open and accountable business processes. She stresses the importance of diversity and inclusion in the creation of moral and responsible AI systems. She also encourages businesses and decision-makers to give underrepresented populations’ demands and worries first priority while developing and implementing computer vision technologies.\nGebru’s presentation serves as a reminder of the essential part AI practitioners and researchers must play in influencing the creation and use of computer vision technologies. We can progress toward developing AI systems that are beneficial to every member of society by considering the ethical implications of these systems and including a variety of viewpoints into their development.\nTL;DR In order to create ethical and just predictive modeling systems, we need to prioritize the need for diverse and inclusive development and implementation practices.\n\n\n\n\nHow can we address the issue of biased data sets in computer vision technology, and what strategies can be used to prevent the continuation of systemic discrimination?\nWhat role should companies and policymakers play in regulating the use of computer vision technology, and what policies and practices would you recommend?\nGiven the potential for danger/harm caused by computer vision technology, what ethical considerations should AI researchers keep in mind when designing and deploying these models?\nCan you share any examples of organizations or initiatives that you believe are making progress in addressing the ethical implications of AI, and what we can learn from them?\nHow can we better educate the public about the ethical implications of computer vision technology, and what steps can be taken to increase awareness and engagement on this issue?\n\n\n\n\n\n\ntheft normalized > - scraping images - might not be an image peeople want taken > - procarious workforce that can’t advocate for themselves  > > - people are scared to lose opportunities > - lack of enforcement, copyright etc\n\nIndependent research org vs larger tech companies - She was fired when she spoke out at a larger tech companies - People are too scared to say anything at companies like google - her company to beholden to that incentive - She still has to fundraise for her institute - Not only her job on the line but also everyone that works at the institution - Can create an environment where people can have diverse ideas - Silence no more act - illegal for people to enforce NDA in cases of harrassment, bullying, discrimination –> easier for people to speak up\nseen any imporvements since talk? - hard to change names of NIPS conference, close to porn site name, so much backlash - every little change is so contentous - resistance: GLAZE artist can run their artwork through this software before posting online, confuses ML models so they cannot copy this work > - worked with many artists\nMitigating bias - ways in use cases of computer vision that actively combat discrimination/bias - forensic lab at NYU, connects protest bombs/weapons to certain companies - costa-rica conservation work: plant identification - YOLO - announced his leave from computer vision, cannot ignore the military applications anymore - 1% good does not outweight the 99% bad use cases\nvery few people who are black and women in CV community - ever felt imposter syndrome - seeing unqualified men, man created cult with no educational background - supporter of airstrikes - no imposter syndrome, people make you feel like that - sexism, racism - see how many unqualified people –> drop imposter syndrome - when in enviroments that are waiting for her to fail, then she feels it - about environment and what it instills in you\n\n\n\n\nfounded DAR Institute\nmitigating dangers of AI\nimagining/executing a better tech future\nmillions of exploited workers that are fueling these AI projects > - chat GPT moderator suffering from trauma and PTSD\n\nUtopia for whom? - AGI = artificial general intelligence > - AI that outperforms humans (smart, well educated human) - rootes in eugenics > - not progressive movement - eugenics never went away, even after WWII - focus on “improving the human stock” > - get rid of undesirable traits/people : negative view > - give people the ability to deisgn their children –> design more intelligent kids > - tell desirable people to reproduce more - Second wave eugenics > - post human: a new superior species can be created > - legacy humans: everyone else (less desirable) > - intelligence explosion\ncosmism - humans will merge with technology - develop sentient AI and mind uploading technology\nTESCREAL bundle - historical roots - transcending humanism - Galton - make parents take intelligence exam before reproducing - some people advocating to harm researchers to stop AI apocalypse\nDiscriminatory view - Bostrom: “Blacks are more stupid than whites” > - too many people with lower IQ reproducing too much –> new species - Pelvitz: below an IQ of 120, 0 points - influence > - all billionaires in movements (Elon Musk, etc) donating > - after the 70s researchers dissociate from AI –> lean more towards ML, CV, NLP - Deep mind founded and then bought by Google - Open AI –> Microsoft\nAGI Utopia - AGI will be so intelligent that it can figure out a solution/what to do to any scenario - morally superior AGI enhanced transhuman minds benefitting\nAGI Utopia for who? - ” On the dangers of stochastic parents…” - text to image models - used for deep fakes, overly sexualizing women, harrasment campaigns - resources not going to organizations around the world who serve their own communities, goes to just one community > - poor people get AI doctors, ruch get humans\nNo language left behind - investor pull out of smaller companies - larger companies often use a data set that is an output of another dataset = training on test data = NO! - NLLB doing much worse than ghana NLP\nAGI Apocalypse - TESCREALists argue probability of existential risk –> any event that would destroy our chances of creating utopia happening this century = high - morally obliged to create AGI Utopia and prevent AGI Apocalypse - Anthromorphising artifcats allows builders to avoid accountability - depply religous –> everlasting life\nunsafe and unscientific\n\n\n\nDr. Gebru’s talk focused on aritificial intelligence, specifically artificial general intellengence (AGI) and its relateion to eugnics. AGI is an aritficial intellegence algorithm or software that can outperform a smart, well-educated human. She was able to shed light on some of the idealogies that drive the AGI movement forward. She, and some collaborators have coined the term TESCREAL to desribe some of these motivations.\nThe “T” stands for transhumanism, which is the belief that people should evolve as a species by merging biological and synthetic technology to enhance themselves. More specifically, there would be two different species of the human race. The first: post-human - humans who are smarter, more intelligent and thus would be allowed to reproduce more. The second: legacy humans - those who are deemed “lesser than or defective” and would not get to reproduce.\nThe E stands for extropianism which argues that human can reverse or alter entropy to have an extended or everlasting life.\nThe S stands for singularitianism which is the belief that technology will continue to evolve and eventually design itself, leading to a technology explosion.\nThe C standing for cosmism - the idea that humans will merge with technology and the development sentient AI and mind uploading technology.\nThe EA refers to effective altruism which is the belief to do the most good.\nLongtermism is a philosopy that prioritizes the maximization of future intelligences. These ideas all strive for a utopia but a utopia for who?\nChatGPT provides an AI chatbot full of information, but at the expense of who? There have been stories of CHATGPT employees who moderate the algorithms responses and have been traumatized by the experience. Some have even developed PTSD.\nShe also touched on the dangers of AGI. One aspect was the dangers of data collection and image scraping. She illuded to the fact that many images are scraped from the internet without consent and used for controversial applications (protester identificaton). She also described that this would reinforce racial accesibily disparities. Once AI is good enough –> Poor people get AI doctors: rich people get real life in person doctors.\nReflecting back on this talk, I am definitely happy that I attended. While I might not agree with her whole argument, there are parts that I support. I do agree that internet data scraping has become a larger issue. A significant amount of data is scraped everyday and while people choose to put their information on the internet, they often aren’t aware of all possible applications. The example of the protester identifcant is one specific example of this. Had people known their photos were being used for this application, some would probably object.\n\n\n\nI learned alot during Dr. Gebru’s talk. Before this experience, I had never heard of the term AGI, only AI. I was not aware that AGI had a specific name or what its purpose was. I had also never thought about relating AI and/or computer science to the eugenics. It was interesting to hear Dr. Gebru’s take on this topic as well. Although, I wished that she had touched on the connection from AI to AGI to eugenics a little bit more. I was having trouble following along as to how AGI was reinforcing eugenics. When I think of eugenics i was thing WWII - gene manipulation but it seems like a bit of a stretch to correlate AGI to that. But, with that being said I definitely learned something. even if I don’t agree 100% it aided in my understand of current issues in the AI field. I will also think about this talk moving forward; specifically, what the greater impact of an algorithm might be or the potential dangers/biases of AI.\nThe part of the discussion I enjoyed most was our conversation about imposter syndrome. I like how Dr. Gebru called it as it is; not imposter syndrome, but racism, sexism, etc. That was very empowering to me"
  },
  {
    "objectID": "posts/Unsupervised Learning Blog Post/Unsupervised Learning Nb.html",
    "href": "posts/Unsupervised Learning Blog Post/Unsupervised Learning Nb.html",
    "title": "Unsupervised Learning",
    "section": "",
    "text": "This is in an optional blog post that focuses on using linear algebra for unsupervised learning. I chose to focus on the first dection : Image compression with Singular value decomposition.\nSVD for a real matrix \\(A \\in R^{mxn}\\) is \\[A = UDV^{T}\\] where \\(D \\in R^{mxn}\\) has non zero entries and where \\(U \\in R^{mxm}\\) and \\(V \\in R^{nxn}\\) are orthogonal matrices.\n\n\n\n\nfrom matplotlib import pyplot as plt\nimport numpy as np\nimport PIL\nimport urllib\n\ndef read_image(url):\n    return np.array(PIL.Image.open(urllib.request.urlopen(url)))\n\nHere we will read in our image, my dog :)\n\nurl = \"https://i.imgur.com/b2Xy4Et.jpeg\"\nimg = read_image(url)\n\nNext, we will convert our RGB image into greyscale. Let’s visualize this:\n\nfig, axarr = plt.subplots(1, 2, figsize = (7, 3))\n\ndef to_greyscale(im):\n    return 1 - np.dot(im[...,:3], [0.2989, 0.5870, 0.1140])\n\ngrey_img = to_greyscale(img)\n\naxarr[0].imshow(img)\naxarr[0].axis(\"off\")\naxarr[0].set(title = \"original\")\n\naxarr[1].imshow(grey_img, cmap = \"Greys\")\naxarr[1].axis(\"off\")\naxarr[1].set(title = \"greyscale\")\n\n[Text(0.5, 1.0, 'greyscale')]\n\n\n\n\n\nLet’s create a svd construction function. We can call a built in numpy package on our image array. Sigma is a numpy array containing the singular values of our image. We can reconstruct our image from the equation in the introduction by constructing D, the diagonal matrix containg sigma values. Then, we can matrix multiply U,D, and V to reconstruct our image.\nBut, one of the many reasonse we like svd is that we can approximate by using a subset of each matrix. We only need the first k columns of U, the top k singular values in D and the first k rows of V. Assume k is smaller than m and n. Then we can matrix multiply the submatrices for our reconstruction.\n\ndef svd_reconstruct(img,k):\n    U,sigma, V = np.linalg.svd(img)\n    D = np.zeros_like(img,dtype=float)\n    D[:min(img.shape),:min(img.shape)] = np.diag(sigma)    \n    U_ = U[:,:k]\n    D_ = D[:k,:k]\n    V_=V[:k,:]\n    A_ = U_ @ D_ @ V_\n    return A_\n\n\ngrey_img.shape\n\n(480, 360)\n\n\n\n\nNow I will perform an experiment in which I reconstruct my image with different k values. I will increase k until I can no longer differentiate my original image from the reconstructed approximation. I will also determine the ammount of storage.\n\nreconstructions = []\n\nfor i in range (1,7):\n    reconstructions.append((svd_reconstruct(grey_img,12*i),12*i))\n\n\nfig,axs = plt.subplots(2,4, figsize=(20,15))\n\n\ncount = 0\nfor i in range(2):\n    for j in range(3):\n        axs[i][j].imshow(reconstructions[count][0],cmap = \"Greys\")\n        axs[i][j].set_title(str(reconstructions[count][1])+ \" Components, \\n % storage =  \" + str(round(compression_factor(reconstructions[count][1],grey_img)*100,2))) \n        axs[i][j].axis(\"off\")\n        count+=1\naxs[0][3].imshow(grey_img,cmap=\"Greys\")\naxs[0][3].axis(\"off\")\naxs[0][3].set_title(\"orig\")\n\naxs[1][3].axis(\"off\")\n\n(0.0, 1.0, 0.0, 1.0)\n\n\n\n\n\n\n\n\nIf an mxn image needs mn pixels(numbers) to represent it, than our original greyscale image needs \\(480 * 360 = 172,800\\) numbers. Now we will consider our new images. We only need the first k columns of U, the top k singular values in D and the first k rows of V. If \\(\\vec{u}\\) is an \\(m x k\\) vector and \\(\\vec{v}\\) is a \\(k x n\\) vector, then the product is a \\(m x n\\) maxtrix with \\(m*n\\) items. However, these items can be stored by just storing \\(\\vec{u_k}\\) and \\(\\vec{v_k}\\). Storing the product \\(D_k \\vec{u_k} \\vec{v_k}\\) can be stored with \\(m+n+k\\) items because we just need to the items in D, k singular values. So, we simply get \\((m+n+1)k\\) items for a reconstructed approximation. And we can now calculate the storage needed for all of our images above.\n\ndef compression_factor(k,img):\n    img_shape = img.shape\n    original_storage = img_shape[0]*img_shape[1]\n    new_storage = (img_shape[0]+img_shape[1]+1)*k\n    return new_storage/original_storage\n\ndef compression_factor_to_k(compression_factor,img):\n    img_shape = img.shape\n    original_storage = img_shape[0]*img_shape[1]\n    new_storage = compression_factor*original_storage\n    k = new_storage/(img_shape[0]+img_shape[1]+1)\n    return round(k)\n\nNow we can perform svd given a specific compression factor. Using the compression factor equation \\[(new\\_image\\_storage/original\\_image\\_storage) = compression factor\\] we can find k. \\[new\\_image\\_storage = (compression factor) * original\\_image\\_storage)\\] and \\[new\\_image\\_storage = (m+n+1)*k\\]. So we can set the two sides equal to each other \\[(m+n+1)*k = (compression factor) * original\\_image\\_storage\\] and solve for k. \\[k = \\frac{(compression factor) * original\\_image\\_storage}{(m+n+1)}\\]\n\ndef svd_by_CF(compression_factor,img):\n    k = compression_factor_to_k(compression_factor,img)\n    return svd_reconstruct(img,k)\n\nnew_image = svd_by_CF(.292,grey_img)\nplt.imshow(new_image,cmap = \"Greys\")\n\n<matplotlib.image.AxesImage at 0x7f8c4bf64100>\n\n\n\n\n\n\n\n\nThis blog post was pretty cool. I liked working with images and really visualizing the reconstructions in comparision to the original photo. It seems like there was not visible difference between our k = 72 image and our original. Storing this photo only takes 35% of the original storage space!"
  },
  {
    "objectID": "posts/example-blog-post/index.html",
    "href": "posts/example-blog-post/index.html",
    "title": "Hello Blog",
    "section": "",
    "text": "This is an example of the blog posts that you’ll submit as your primary form of learning demonstration in CSCI 0451. I created this post by modifying the file posts/example-blog-post/index.ipynb in VSCode. You can also use JupyterLab for this editing if you prefer. Finally, it is possible to write blog posts without using notebooks by writing .qmd files, as illustrated here."
  },
  {
    "objectID": "posts/example-blog-post/index.html#math",
    "href": "posts/example-blog-post/index.html#math",
    "title": "Hello Blog",
    "section": "Math",
    "text": "Math\nIn addition to regular text using the Markdown specification, you can also write mathematics, enclosed between dollar signs. The syntax for writing math is very similar to the syntax used in the \\(\\LaTeX\\) markup language. For example, $f(x) \\approx y$ renders to \\(f(x) \\approx y\\). To place complex mathematical expressions on their own lines, use double dollar signs. For example, the expression\n$$\\mathcal{L}(a, b) = \\sum_{i = 1}^n (ax_i + b - y_i)^2$$\nrenders to:\n\\[\\mathcal{L}(a, b) = \\sum_{i = 1}^n (ax_i + b - y_i)^2\\;.\\]\nBehind the scenes, math is powered by the MathJax engine. For more on how to write math, check this handy tutorial and quick reference."
  },
  {
    "objectID": "posts/final_blog_post/final-project-blog-post.html",
    "href": "posts/final_blog_post/final-project-blog-post.html",
    "title": "Urban Air Pollution Predicted by Income and Racial Demographics",
    "section": "",
    "text": "References\n\nAssociation, American Lung. 2023. “Disparities in the Impact of Air Pollution.” American Lung Association. https://www.lung.org/clean-air/outdoors/who-is-at-risk/disparities.\n\n\nDaouda, Misbath, Lucas Henneman, Jeff Goldsmith, Marianthi-Anna Kioumourtzoglou, and Joan A. Casey. 2022. “Racial /Ethnic Disparities in Nationwide PM 2.5 Concentrations Perils of Assuming a Linear Relationship.” Environmental Health Perspectives 130: 077701. https://doi.org/10.1289/EHP11048.\n\n\nJbaily, A., X. Zhou, and J. Liu. 2022. “Air Pollution Exposure Disparities Across US Population and Income Groups.” Nature 601. https://doi.org/https://doi.org/10.1038/s41586-021-04190-y.\n\n\nLane, Haley M., Rachel Morello-Frosch, Julian D. Marshall, and Joshua S. Apte. 2022. “Historical Redlining Is Associated with Present-Day Air Pollution Disparities in u.s. Cities.” Environmental Science and Technology Letters. https://doi.org/https://doi.org/10.1021/acs.estlett.1c01012.\n\n\nLiu, Jiawen, Lara P. Clark, Matthew J. Bechle, Anjum Hajat, Sun-Young Kim, Allen L. Robinson, Lianne Sheppard, Adam A. Szpiro, and Julian D. Marshall. 2021. “Disparities in Air Pollution Exposure in the United States by Race/Ethnicity and Income, 1990–2010.” Environmental Health Perspectives 129 (12): 127005. https://doi.org/10.1289/EHP8584."
  }
]