[
  {
    "objectID": "posts/Perceptron Blog Post/Perceptron Blog.html",
    "href": "posts/Perceptron Blog Post/Perceptron Blog.html",
    "title": "Perceptron Blog Post",
    "section": "",
    "text": "link to perceptron code\n\n\nIn this blog post we will delve into the perceptron algorithm. I have implemented a algorithm that separates binary data. We have also conducted experiments that push the limits of our algorithm and show cases different patterns\n\n\n\n\nimport pandas as pd\nimport numpy as np\nimport seaborn as sns\nfrom matplotlib import pyplot as plt\nfrom sklearn.datasets import make_blobs\n\n\n#importing perceptron.py code and updating\nimport perceptron\nfrom perceptron import Perceptron\nimport importlib\nimportlib.reload(perceptron)\n\n<module 'perceptron' from '/Users/mtarantola@middlebury.edu/Downloads/Machine Learning/miatarantola.github.io/posts/Perceptron Blog Post/perceptron.py'>\n\n\n\n\n\nThe following function is used to update the perceptron weights:\n\n\\(\\tilde{w} ^{(t+1)} = \\tilde{w} ^ {(t)} + \\mathbb{1}(\\tilde{y_i} \\langle \\tilde{w}^{(t)}, \\tilde{x_i} \\rangle < 0) \\tilde{y_i} \\tilde{x_i}\\)\n\nIn order to implement this algorithm, we must follow these steps.\n\\({1.}\\) pick a random index \\(~{i} \\in\\) n. \n\\({2. }\\) predict the label, \\(\\hat{y_i}\\), of our randomly selected data point, \\(\\tilde{x_i}\\).\n\nTo do so we calculate the dot product, \\(\\langle \\tilde{w}^{(t)}, \\tilde{x_i} \\rangle\\) and compare the resulting value to 0.\n\n\nif the result is greater than 0 return 1, otherwise return -1.\n\n\\({3.}\\) compute \\(\\mathbb{1}(\\tilde{y_i} \\langle \\tilde{w}^{(t)}, \\tilde{x_i} \\rangle < 0)\\)\n\nGiven our predicted label, \\(\\hat{y_i}\\) , of 1 or -1 we can multiply by \\(\\tilde{y_i}\\) to check for correctness\n\n\nIf \\(\\hat{y_i} \\tilde{y_i} <0\\) then the signs of our observed and predicted label do not match. If \\(\\hat{y_i} \\tilde{y_i} >0\\) then the signs of our predicted and observed label match\n\nSo, \\(\\mathbb{1}(\\tilde{y_i} \\langle \\tilde{w}^{(t)}, \\tilde{x_i} \\rangle < 0)\\) returns 1 if model predicted incorrectly and \\(\\tilde{y_i} \\tilde{x_i}\\) is added to the pre-existing weights.\nOtherwise the expression returns 0 for a correctly prediction and no update is performed\n\n\n\n\n\n\nnp.random.seed(8674)\n\nn = 100\np_features = 3\n\nX1, y1 = make_blobs(n_samples = 100, n_features = 2,centers=[(-1.7,-1.7),(1.7,1.7)])\n\nfig1 = plt.scatter(X1[:,0], X1[:,1], c = y1)\nxlab = plt.xlabel(\"Feature 1\")\nylab = plt.ylabel(\"Feature 2\")\n\n\n\n\n\np1 = Perceptron()\n\n\np1.fit(X1,y1,100000)\n\n\nfig1 = plt.plot(p1.history)\nxlab = plt.xlabel(\"Iteration\")\nylab = plt.ylabel(\"Accuracy\")\n\n\n\n\n\np1.score(X1,y1)\n\n1.0\n\n\n\ndef draw_line(w, x_min, x_max):\n  x = np.linspace(x_min, x_max, 101)\n  y = -(w[0]*x + w[2])/w[1]\n  plt.plot(x, y, color = \"black\")\n\nfig = plt.scatter(X1[:,0], X1[:,1], c = y1)\nfig = draw_line(p1.w, -2, 2)\n\nxlab = plt.xlabel(\"Feature 1\")\nylab = plt.ylabel(\"Feature 2\")\n\n\n\n\nFor this experiment we ran our perceptron algorithm on linearly separable data. We can see that the reuslting line is a good separator as it clearly separates our two labels. It is interesting to see that the accuracy decreases before it increases. Another result that suggests our separator is a good fit is that our algorithm stops before the maximum number of iterations allowed\n\n\n\nnp.random.seed(7810) #7810\n\nn = 100\np_features = 3\n\nX2, y2 = make_blobs(n_samples = 100,n_features=2, centers=2)\n\nfig2 = plt.scatter(X2[:,0], X2[:,1], c = y2)\nxlab = plt.xlabel(\"Feature 1\")\nylab = plt.ylabel(\"Feature 2\")\n\n\n\n\n\np2 = Perceptron()\n\n\np2.fit(X2,y2,1000)\n\n\nfig3 = plt.plot(p2.history)\nxlab = plt.xlabel(\"Iteration\")\nylab = plt.ylabel(\"Accuracy\")\n\n\n\n\n\np2.score(X2,y2)\n\n0.5\n\n\n\nfig = plt.scatter(X2[:,0], X2[:,1], c = y2)\nfig = draw_line(p2.w, -2, 2)\n\nxlab = plt.xlabel(\"Feature 1\")\nylab = plt.ylabel(\"Feature 2\")\n\n\n\n\nThis experiment displays the use of our perceptron algorithm on nonlinearly separable data. As shown above, the resulting line is not a good separater. In fact, it isn’t separating any data. We can also see the inaccuracy by tracking the accuracy over iterations. We can see that the algorihtm is not converging to one set of weights and thus has not found an optimizer.\n\n\n\n\nnp.random.seed(7810) #7810\n\nn = 100\n\nX3, y3 = make_blobs(n_samples = 100,n_features=6, centers=2)\n\n\np3 = Perceptron()\n\n\np3.fit(X3,y3,1000)\n\n\nfig4 = plt.plot(p3.history)\nxlab = plt.xlabel(\"Iteration\")\nylab = plt.ylabel(\"Accuracy\")\n\n\n\n\n\np3.score(X3,y3)\n\n1.0\n\n\nYes, I do believe that my data is linearly separable because my perceptron’s accuracy converges to 1 after 18 iterations. This means that my perceptron reached 100% accuracy and did not complete upon reaching that maximum number of iterations.\n\n\n\n\nThe time complexity for a single iteration of the perceptron algorithm is O(p) because predicting the label of a single data point requires calculating the dot product of x and w. Thus, np iterates over the p features of x to calulate the dot product. All other steps of this equation invlove simple multiplication or addition which are O(1)."
  },
  {
    "objectID": "posts/example-blog-post/index.html",
    "href": "posts/example-blog-post/index.html",
    "title": "Hello Blog",
    "section": "",
    "text": "This is an example of the blog posts that you’ll submit as your primary form of learning demonstration in CSCI 0451. I created this post by modifying the file posts/example-blog-post/index.ipynb in VSCode. You can also use JupyterLab for this editing if you prefer. Finally, it is possible to write blog posts without using notebooks by writing .qmd files, as illustrated here."
  },
  {
    "objectID": "posts/example-blog-post/index.html#math",
    "href": "posts/example-blog-post/index.html#math",
    "title": "Hello Blog",
    "section": "Math",
    "text": "Math\nIn addition to regular text using the Markdown specification, you can also write mathematics, enclosed between dollar signs. The syntax for writing math is very similar to the syntax used in the \\(\\LaTeX\\) markup language. For example, $f(x) \\approx y$ renders to \\(f(x) \\approx y\\). To place complex mathematical expressions on their own lines, use double dollar signs. For example, the expression\n$$\\mathcal{L}(a, b) = \\sum_{i = 1}^n (ax_i + b - y_i)^2$$\nrenders to:\n\\[\\mathcal{L}(a, b) = \\sum_{i = 1}^n (ax_i + b - y_i)^2\\;.\\]\nBehind the scenes, math is powered by the MathJax engine. For more on how to write math, check this handy tutorial and quick reference."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "My Awesome CSCI 0451 Blog",
    "section": "",
    "text": "An blog post illustrating the key techniques of gradient descent\n\n\n\n\n\n\nMar 9, 2023\n\n\nMia Tarantola\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\nAn blog post illustrating course material on perceptrons\n\n\n\n\n\n\nFeb 19, 2023\n\n\nMia Tarantola\n\n\n\n\n\n\n  \n\n\n\n\n\n\n\n\nAn example blog post illustrating the key techniques you’ll need to demonstrate your learning in CSCI 0451.\n\n\n\n\n\n\nJan 10, 2023\n\n\nPhil Chodrow\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog"
  },
  {
    "objectID": "posts/Gradient Descent Blog Post/Gradient_Descent_blog.html",
    "href": "posts/Gradient Descent Blog Post/Gradient_Descent_blog.html",
    "title": "Gradient Descent",
    "section": "",
    "text": "We are looking at the use of gradient descent for optimization and the logistic loss problem. In this assignment I implement gradient descent for logistic regression, implement stochastic gradient descent and perform several experiments that test the limits of the algorithms\n\n\n\n\nimport importlib\nimport gradient_descent\nfrom gradient_descent import LogisticRegression \n\n%load_ext autoreload\n%autoreload 2\n\nfrom sklearn.datasets import make_blobs, make_circles\nfrom matplotlib import pyplot as plt\nimport numpy as np\nnp.seterr(all='ignore') \n\n{'divide': 'warn', 'over': 'warn', 'under': 'ignore', 'invalid': 'warn'}"
  },
  {
    "objectID": "posts/Gradient Descent Blog Post/Gradient_Descent_blog.html#stochastic-descent",
    "href": "posts/Gradient Descent Blog Post/Gradient_Descent_blog.html#stochastic-descent",
    "title": "Gradient Descent",
    "section": "Stochastic Descent",
    "text": "Stochastic Descent\n\nnp.random.seed(8674)\n\nX2, y2 = make_blobs(n_samples = 100, n_features = p_features-1,centers=[(-1.7,-1.7),(1.7,1.7)])\n\nfig2 = plt.scatter(X2[:,0], X2[:,1], c = y2)\nxlab = plt.xlabel(\"Feature 1\")\nylab = plt.ylabel(\"Feature 2\")\n\n\n\n\n\nLR2 = LogisticRegression()\nLR2.fit_stochastic(X2, y2, alpha = 0.1, max_epochs = 1000, batch_size = 15)\n\nThe Stochastic fit function beginns similiarly to the original gradient descent function: > - create X_ > - generate random weight vector of size features+1 > - set previous loss = infinity\nThen we have to iterate thrugh the following for the number of max epochs or until the loss converges:\n\n\nshuffle the points randomly\npick the first random k points and update the weights vector using the stochastic gradient\npick the next set of random points and repeat\nupdate the loss and score history\nreshuffle the points randomly and iterate again\n\n\n\n\nthe gradient function is the same as the original one, we are just inputting a subset of X_ and y_ into the function repeatedly\n\n\n\nfig2 = plt.scatter(X2[:,0], X2[:,1], c = y2)\nfig2 = draw_line(LR2.w, -2, 2)\n\nxlab = plt.xlabel(\"Feature 1\")\nylab = plt.ylabel(\"Feature 2\")\n\n\n\n\n\nprint(LR2.loss_history[-3])\nprint(LR2.loss_history[-2])\nprint(LR2.loss_history[-1])\nprint(LR2.score_history[-1])\n\n0.0033704921863074765\n0.003368276616639715\n0.0033660810616696095\n1.0\n\n\nThis is a good separator as our loss is close to 0 and our score is close to 1"
  },
  {
    "objectID": "posts/Gradient Descent Blog Post/Gradient_Descent_blog.html#comparing-methods",
    "href": "posts/Gradient Descent Blog Post/Gradient_Descent_blog.html#comparing-methods",
    "title": "Gradient Descent",
    "section": "Comparing methods",
    "text": "Comparing methods\n\nLR = LogisticRegression()\nLR.fit_stochastic(X2, y2, \n                  max_epochs = 1000, \n             \n                  batch_size = 10, \n                  alpha = .05) \n\nnum_steps = len(LR.loss_history)\nplt.plot(np.arange(num_steps) + 1, LR.loss_history, label = \"stochastic gradient (a=0.05)\")\n\nLR = LogisticRegression()\nLR.fit_stochastic(X2, y2, \n                  max_epochs = 1000, \n                  batch_size = 10, \n                  alpha = .1)\n\nnum_steps = len(LR.loss_history)\nplt.plot(np.arange(num_steps) + 1, LR.loss_history, label = \"stochastic gradient a = .1\")\n\nLR = LogisticRegression()\nLR.fit(X2, y2, alpha = .05, max_epochs = 1000)\n\nnum_steps = len(LR.loss_history)\nplt.plot(np.arange(num_steps) + 1, LR.loss_history, label = \"gradient\")\n\nplt.loglog()\n\nlegend = plt.legend() \n\n\n\n\nFor these settings, we can see that the stochastic methods are performing much better than the regular gradient descent method. All three methods have a smooth decline in loss, but the stochastic gradient seems to have had the fastest decline. I believe the the gradient methods would need more epochs to find a better solution."
  },
  {
    "objectID": "posts/Gradient Descent Blog Post/Gradient_Descent_blog.html#experiment-alpha-is-too-large",
    "href": "posts/Gradient Descent Blog Post/Gradient_Descent_blog.html#experiment-alpha-is-too-large",
    "title": "Gradient Descent",
    "section": "Experiment: alpha is too large",
    "text": "Experiment: alpha is too large\n\nnp.random.seed(4001)\n\nn = 100\np_features = 3\n\nX3, y3 = make_blobs(n_samples = 100, n_features = p_features-1,centers=[(-1.7,-1.7),(1.7,1.7)])\n\nfig1 = plt.scatter(X3[:,0], X3[:,1], c = y3)\nxlab = plt.xlabel(\"Feature 1\")\nylab = plt.ylabel(\"Feature 2\")\n\n\n\n\n\n#alpha is too large\nLR3 = LogisticRegression()\nLR3.fit(X3, y3, alpha = 200, max_epochs = 100)\n\n#alpha is a normal value\nLR5 = LogisticRegression()\nLR5.fit(X3, y3, alpha = .01, max_epochs = 1000)\n\n\n\n#alpha = 200\nfig3 = plt.scatter(X3[:,0], X3[:,1], c = y3)\nfig3 = draw_line(LR3.w, -2, 2)\n\nxlab = plt.xlabel(\"Feature 1\")\nylab = plt.ylabel(\"Feature 2\")\nLR3.loss_history\nLR3.w\n\narray([19.43660085, 18.2651358 , -4.47025268])\n\n\n\n\n\n\n#alpha = .01\nfig3 = plt.scatter(X3[:,0], X3[:,1], c = y3)\nfig3 = draw_line(LR5.w, -2, 2)\n\nxlab = plt.xlabel(\"Feature 1\")\nylab = plt.ylabel(\"Feature 2\")\n\n\n\n\n\n\nnum_steps1 = len(LR3.loss_history)\nplt.plot(np.arange(num_steps1) + 1, LR3.loss_history, label = \"(a=200)\")\n\nnum_steps2 = len(LR5.loss_history)\nplt.plot(np.arange(num_steps2) + 1, LR5.loss_history, label = \"a =.01\")\n\n\n\n\nlegend = plt.legend() \n\n\n\n\nWe can see that both alphas result in good separators. But, we have discovered one of the caveats of logistic regression. It can combat alphas that are too large by increasing all of the weights. So, for data that is linearly separable the model performs as good as you want it to. Hence, we will now investigate non-linearly separable data\n\nNon linearly separable\n\nnp.random.seed(8680)\n\nn = 100\np_features = 4\n\nX4, y4 = make_blobs(n_samples = 100, n_features = p_features-1,centers=[(-1,-1),(1,1)])\n\n\n\nfig1 = plt.scatter(X4[:,0], X4[:,1], c = y4)\nxlab = plt.xlabel(\"Feature 1\")\nylab = plt.ylabel(\"Feature 2\")\n\n\n\n\n\nLR6 = LogisticRegression()\nLR6.fit(X4, y4, alpha = 100, max_epochs = 1000)\n\nLR7 = LogisticRegression()\nLR7.fit(X4, y4, alpha = 1, max_epochs = 1000)\n\n\n\nfig3 = plt.scatter(X4[:,0], X4[:,1], c = y4)\nfig3 = draw_line(LR6.w, -2, 2)\n\n\n\n\n\nfig3 = plt.scatter(X4[:,0], X4[:,1], c = y4)\nfig3 = draw_line(LR7.w, -2, 2)\n\n\n\n\n\n\nnum_steps1 = len(LR6.loss_history)\nplt.plot(np.arange(num_steps1) + 1, LR6.loss_history, label = \"(a=100)\")\n\n\nnum_steps1 = len(LR7.loss_history)\nplt.plot(np.arange(num_steps1) + 1, LR7.loss_history, label = \"(a=1)\")\n\n\nlegend = plt.legend() \n\n\n\n\nHere we can see that our model performs fairly well at a smaller alpha (1) as the line mostly separates the data. However, for a larger alpha the algorithm does not work well. It is unable to converge and thus results in a bad separater and the loss bounces around"
  },
  {
    "objectID": "posts/Gradient Descent Blog Post/Gradient_Descent_blog.html#experiment-batch-size",
    "href": "posts/Gradient Descent Blog Post/Gradient_Descent_blog.html#experiment-batch-size",
    "title": "Gradient Descent",
    "section": "Experiment batch size",
    "text": "Experiment batch size\n\nnp.random.seed(8680)\n\nn = 100\np_features = 4\n\nX4, y4 = make_blobs(n_samples = 100, n_features = p_features-1,centers=[(-1.7,-1.7),(1.7,1.7)])\n\n\nLR = LogisticRegression()\nLR.fit_stochastic(X4, y4, \n                  max_epochs = 10000, \n                  batch_size = 8, \n                  alpha = .1) \n\nnum_steps = len(LR.loss_history)\nplt.plot(np.arange(num_steps) + 1, LR.loss_history, label = \"stochastic gradient (batch_size=8)\")\n\nLR = LogisticRegression()\nLR.fit_stochastic(X4, y4, \n                  max_epochs = 10000, \n                  batch_size = 80, \n                  alpha = .1)\n\nnum_steps = len(LR.loss_history)\nplt.plot(np.arange(num_steps) + 1, LR.loss_history, label = \"stochastic gradient (batch_size=80)\")\n\n\nplt.loglog()\n\nlegend = plt.legend() \n\n\n\n\nFor this experiment I compared a stochastic batch size of 8 to a batch size of 80. We can see that a smaller batch size allows the algorithm to converge must faster. Increasing the batch size by a factor of 8 almost increased the number of needed epochs by a factor of 10"
  }
]